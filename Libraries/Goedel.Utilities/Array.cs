using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace Goedel.Utilities {

    /// <summary>
    /// Static class containing extension methods for array manipulation.
    /// </summary>
    public static class ArrayUtilities {

        /// <summary>Test to see if two arrays are equal.
        /// </summary>
        /// <param name="Test1">First test value</param>
        /// <param name="Test2">Second test value</param>
        /// <returns>true if and only if the two arrays are of the same size and each
        /// element is equal.</returns>
        public static bool IsEqualTo(this byte[] Test1, byte[] Test2) {
            if ((Test1 == null) & (Test2 == null)) {
                return true;
                }
            if (Test2 == null) {
                return false;
                }
            if (Test1 == null) {
                return false;
                }
            if (Test1.Length != Test2.Length) {
                return false;
                }
            for (int i = 0; i < Test1.Length; i++) {
                if (Test1[i] != Test2[i]) {
                    return false;
                    }
                }

            return true;
            }

        /// <summary>
        /// Copy data into the destination array at the specified index. If there is insufficient
        /// space, the remaining data is silently discarded. The main use for this is for inside 
        /// key derivation functions where the amount of key generated by the function may be greater
        /// than the amount needed.
        /// </summary>
        /// <param name="Destination">The destination array</param>
        /// <param name="Offset">Offset in the destination array</param>
        /// <param name="Data">Data to be written</param>
        /// <returns>Offset of the next byte to be written.</returns>
        public static int AppendChecked (this byte[] Destination, int Offset, byte [] Data) {
            if (Offset > Destination.Length) {
                return Destination.Length;                 }

            var Length = Offset + Data.Length <= Destination.Length ?
                      Data.Length : Destination.Length - Offset; // remaining space

            Array.Copy(Data, 0, Destination, Offset, Length);
            return Offset + Length;
            }

        /// <summary>
        /// Create a duplicate copy of a byte array. This allows the original data to be modified
        /// or disposed of.
        /// </summary>
        /// <param name="Source">The source array</param>
        /// <returns>The copied array</returns>
        public static byte[] Duplicate(this byte[] Source) {
            var Result = new byte[Source.Length];
            Array.Copy(Source, Result, Source.Length);
            return Result;
            }

        /// <summary>
        /// Conditional truncation of an output value. If the value Length is zero,
        /// returns the source array. Otherwise a new array is created and the first
        /// Length bits of the source array copied into it and the new array returned.
        /// </summary>
        /// <param name="Source">The source array</param>
        /// <param name="Length">The truncation length, 0 for no truncation.</param>
        /// <returns>Truncated value</returns>
        public static byte[] OrTruncated (this byte[] Source, int Length) {
            if (Length <= 0) {
                return Duplicate(Source);
                }
            Length = Length / 8; // Convert to bytes
            var Result = new byte[Length];
            Array.Copy(Source, Result, Length);

            return Result;
            }


        /// <summary>
        /// Wrapper for the Dictionary Add method to signal success or failure by means of a
        /// boolean return value rather than throwing an error.
        /// </summary>
        /// <typeparam name="TKey">The Key type</typeparam>
        /// <typeparam name="TValue">The Value type, null values are pruned.</typeparam>
        /// <param name="Dictionary">The dictionary to add to</param>
        /// <param name="Key">The key to add</param>
        /// <param name="Value">The value to add</param>
        /// <returns>True if a new entry was added, otherwise false.</returns>
        public static bool AddSafe<TKey, TValue> (this IDictionary<TKey, TValue> Dictionary, TKey Key, TValue Value ) {
            if (Value == null) {
                return false;
                }

            try {
                Dictionary.Add(Key, Value);
                return true;
                }
            catch {
                return false;
                }

            }

        /// <summary>
        /// Wrapper for the Dictionary Add method to signal success or failure by means of a
        /// boolean return value rather than throwing an error.
        /// </summary>
        /// <typeparam name="TKey">The Key type</typeparam>
        /// <typeparam name="TValue">The Value type, null values are pruned.</typeparam>
        /// <param name="Dictionary">The dictionary to add to</param>
        /// <param name="Key">The key to add</param>
        /// <param name="Value">The value to add</param>
        /// <returns>True if a new entry was added, otherwise false.</returns>
        public static bool ReplaceSafe<TKey, TValue>(this IDictionary<TKey, TValue> Dictionary, TKey Key, TValue Value) {
            if (Value == null) {
                return false;
                }

            try {
                Dictionary.Remove(Key);
                Dictionary.Add(Key, Value);
                return true;
                }
            catch {
                return false;
                }

            }


        /// <summary>
        /// Concatenate the two arrays
        /// </summary>
        /// <param name="First">First array</param>
        /// <param name="Second">Second array</param>
        /// <returns>result</returns>
        public static byte[] Concatenate (this byte[] First, byte[] Second) {
            var Buffer = new byte[First.Length + Second.Length];
            Array.Copy(First, Buffer, First.Length);
            Array.Copy(Second, 0, Buffer, First.Length, Second.Length);
            return Buffer;
            }

        }
    }

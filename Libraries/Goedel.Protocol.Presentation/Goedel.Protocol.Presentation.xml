<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Goedel.Protocol.Presentation</name>
    </assembly>
    <members>
        <member name="T:Goedel.Protocol.Presentation.Connection">
            <summary>
            Base class for connections
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Connection.ClientKeyOut">
            <summary>Key for encrypting outgoing packets under the key established 
            to the host credential alone</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Connection.ClientKeyIn">
            <summary>Key for decrypting incomming packets under the key established 
            to the host credential alone</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Connection.MutualKeyOut">
            <summary>Key for encrypting outgoing packets under the key established 
            to the host and client credentials,</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Connection.MutualKeyIn">
            <summary>Key for decrypting incomming packets under the key established 
            to the host and client credentials,</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ListenerCredential">
            <summary>The host credentials. There is exactly one set of host 
            credentials for a given PortId at a given time. This MAY however
            contain multiple keys (e.g. for different algorithms.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.Listener">
            <summary>The listener to which this connection is bound.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.#ctor(Goedel.Protocol.Presentation.Listener)">
            <summary>
            Base constructor.
            </summary>
            <param name="listener">Listgener to which this connection is bound.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.SerializePacketData(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Serialize ane mutually encrypt a data packet.
            </summary>
            <param name="payload"></param>
            <param name="extensions"></param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ParsePacketData(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Deserialize a mutually encrypted data packet.
            </summary>
            <param name="sourceId"></param>
            <param name="packet"></param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.Write(Goedel.Protocol.Presentation.PacketWriter,System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Write the payload <paramref name="payload"/> with extensions <paramref name="extensions"/>
            to the writer <paramref name="writer"/>.
            </summary>
            <param name="writer">Packet writer to which the data is to be written.</param>
            <param name="payload">The payload data.</param>
            <param name="extensions">Extensions (if used).</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(Goedel.Cryptography.KeyPairAdvanced,System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Perform a key exchange to the host credential only. This is performed by the client during
            connection establishment.
            </summary>
            <param name="privateKey">The private key</param>
            <param name="publicKeyData">The public key in wire format.</param>
            <param name="keyClientHost">Session key used to encrypt/authenticate messages from the client
            to the host.</param>
            <param name="keyHostClient">Session key used to encrypt/authenticate messages from the host
            to the client.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(Goedel.Cryptography.KeyPairAdvanced,Goedel.Cryptography.KeyPairAdvanced,System.Byte[]@,System.Byte[]@)">
            <summary>
            Perform a key exchange to the host credential only. This is performed by the client during
            connection establishment.
            </summary>
            <param name="privateKey">The private key</param>
            <param name="keyPublic">The public key.</param>
            <param name="keyClientHost">Session key used to encrypt/authenticate messages from the client
            to the host.</param>
            <param name="keyHostClient">Session key used to encrypt/authenticate messages from the host
            to the client.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(Goedel.Cryptography.KeyPairAdvanced,System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Perform a key exchange to the host and client credentials. This is performed during
            connection establishment after both sides have obtained an ephemeral to validate their
            keys against.
            </summary>
            <param name="privateKey">The private key</param>
            <param name="publicKeyData">The public key in wire format.</param>
            <param name="keyClientHost">Session key used to encrypt/authenticate messages from the client
            to the host.</param>
            <param name="keyHostClient">Session key used to encrypt/authenticate messages from the host
            to the client.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(Goedel.Cryptography.KeyPairAdvanced,Goedel.Cryptography.KeyPairAdvanced,System.Byte[]@,System.Byte[]@)">
            <summary>
            Perform a key exchange to the host and client credentials. This is performed during
            connection establishment after both sides have obtained an ephemeral to validate their
            keys against.
            </summary>
            <param name="privateKey">The private key</param>
            <param name="publicKey">The public key in wire format.</param>
            <param name="keyClientHost">Session key used to encrypt/authenticate messages from the client
            to the host.</param>
            <param name="keyHostClient">Session key used to encrypt/authenticate messages from the host
            to the client.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.Parse(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ClientState">
            <summary>
            Client side connection state.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientState.Initial">
            <summary>Initial state, sending either Initial or Cloaked.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientState.Challenge">
            <summary>Host challenge received, sending answer.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientState.Write">
            <summary>Connection established, sending packets.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientState.Abort">
            <summary>Connection terminated, cannot be used further.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.ConnectionClient">
            <summary>
            Client connection class.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionClient.ClientCredential">
            <summary>The credential to be presented by the client.</summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionClient.HostCredential">
            <summary>The credential to be presented by the host.</summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionClient.ClientState">
            <summary>The client state.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.#ctor(Goedel.Protocol.Presentation.Listener,System.String,System.String,Goedel.Protocol.Presentation.PortId,Goedel.Protocol.Presentation.PresentationCredential,Goedel.Protocol.Presentation.PresentationCredential)">
            <summary>
            Constructor, establish a client connection for the service 
            <paramref name="protocol"/> at address <paramref name="endpoint"/>.
            </summary>
            <param name="protocol">The service protocol.</param>
            <param name="endpoint">The service address.</param>
            <param name="portID">The port identifier.</param>
            <param name="clientCredential">The client credential.</param>
            <param name="hostCredential">The host credential (if known).</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.SerializeInitial(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Serialize an initial request packet for this connection. Note that the initial 
            packet contains no information that is private to the client. Only an ephemeral
            key is generated and presented.
            </summary>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensions">Extensions to be presented in the plaintext segment.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.SerializeClientExchange(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
             Serialize a client key exchange request made by a client that knows the host credential
             but does not have a host ephemeral to challenge its own private key. The payload
             <paramref name="payload"/> if specified is encrypted to the host credential only.
            </summary>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensions">Plaintext extensions, including answer data responding to a 
            challenge puzzle presented by the host or another party.</param>
            <param name="ciphertextExtensions">Ciphertext extensions, including channel configuration.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.SerializeClientComplete(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
             Serialize a client key exchange request made by a client that knows the host credential
             and has received a recent host ephemeral to challenge its own private key. The payload
             <paramref name="payload"/> if specified is encrypted to both the client and host credentials.
             The client credentials are encrypted to the host credentials but not authenticated to the
             client making the request.
            </summary>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensions">Plaintext extensions, including answer data responding to a 
            challenge puzzle presented by the host or another party.</param>
            <param name="ciphertextExtensions">Ciphertext extensions, including channel configuration.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.Parse(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.ParsePacketHostExchange(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            as a packet of type <see cref="T:Goedel.Protocol.Presentation.PacketHostExchange"/>and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.ParsePacketHostComplete(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            as a packet of type <see cref="T:Goedel.Protocol.Presentation.PacketHostComplete"/>and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionClient.ParsePacketHostChallenge(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            as a packet of type <see cref="T:Goedel.Protocol.Presentation.PacketHostExchange"/>and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ConnectionHost">
            <summary>
            Host (i.e. responder) end of a listener connection.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionHost.HostCredential">
            <summary>The client credential</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionHost.ClientCredential">
            <summary>The client credential</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.#ctor(Goedel.Protocol.Presentation.Listener)">
            <summary>
            Base constructor.
            </summary>
            <param name="listener">Listgener to which this connection is bound.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.SerializeChallenge(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Create a challenge and return it to the recipient together with the host credentials.
            The payload is always sent enclair. Thus this packet format MUST NOT be used for 
            messages other than regular client 
            </summary>
            <param name="payload">Packet payload (if used)</param>
            <param name="plaintextExtensions">Extensions to be presented in the plaintext segment.</param>
            <returns>The packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.SerializeHostExchange(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Create a packet to begin a mutually authenticated exchange.
            </summary>
            <param name="payload">Optional payload data to be mutually encrypted.</param>
            <param name="plaintextExtensions">Extensions to be presented in the plaintext segment.</param>
            <param name="ciphertextExtensions">Extensions to be presented in the ciphertext segment.</param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.SerializeHostComplete(System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Create a packet to complete mutually authenticated exchange.
            </summary>
            <param name="clientEphemeral">The client ephemeral key (public)</param>
            <param name="payload">Optional payload data to be mutually encrypted.</param>
            <param name="plaintextExtensions">Extensions to be presented in the plaintext segment.</param>
            <param name="ciphertextExtensions">Extensions to be presented in the ciphertext segment.</param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.SerializeHostChallenge(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Create a packet to complete mutually authenticated exchange.
            </summary>
            <param name="payload">Optional payload data to be mutually encrypted.</param>
            <param name="plaintextExtensions">Extensions to be presented in the plaintext segment.</param>
            <param name="ciphertextExtensions">Extensions to be presented in the ciphertext segment.</param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.Parse(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionHost.ParsePacketClientComplete(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse the packet <paramref name="packet"/> received from the source <paramref name="sourceId"/>
            as a packet of type <see cref="T:Goedel.Protocol.Presentation.PacketClientComplete"/>and return the parsed packet data.
            </summary>
            <param name="sourceId">The packet source.</param>
            <param name="packet">The packet data.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.EncryptedPacketIdentifier">
            <summary>
            Identifiers used within encrypted data packets.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Atomic">
            <summary>Packet contains a complete message.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Heartbeat">
            <summary>Heartbeat packet, the outbound port and IP address to which the sender 
            directs it.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Serialized">
            <summary>Packet contains a part of a message.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Streamed">
            <summary>Packet contains a part of a message in a streamed connection.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Mezzanine">
            <summary>Mezzanine packet containing an inner packet with the client credentials.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.EncryptedPacketIdentifier.Tunnelled">
            <summary>Packet contains a tunnelled message.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PlaintextPacketType">
            <summary>
            The packet types passed as plaintext.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Error">
            <summary>Report an error to the sender.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Initial">
            <summary>Plaintext request to establish a new connection to the host. This is 
            only used in cases where the client does not have the public key of the host.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientExchange">
            <summary>Encrypted request to establish a new connection to the host.
            This MAY be used in cases where the client has the public key of the host.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientComplete">
            <summary>Client completion of key exchange.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostChallenge">
            <summary>Present a challenge to a client requesting a connection.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostExchange">
            <summary>Present a challenge to a client requesting a connection.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostComplete">
            <summary>Host completion of key exchange.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Rebind">
            <summary>Establish a new binding for the specified connection identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.ErrorCode">
            <summary>
            Error response codes.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCode.UnknownConnection">
            <summary>The request could not be bound to an inbound connection. This could be because
            the source address has changed.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCode.Refused">
            <summary>The request was refused for reasons reserved to the responder.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.Constants">
            <summary>
            Constants class
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.MinimumPacketSize">
            <summary>The minimum packet size.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeNonceAesGcm">
            <summary>Size of packet nonce to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeIvAesGcm">
            <summary>Size of initialization vector / AES nonce to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeTagAesGcm">
            <summary>Size of authentication tag to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeKeyAesGcm">
            <summary>Size of key to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagIv">
            <summary>The KDF info tag to be used to derive initialization vectors.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKey">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKeyClientHost">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKeyHostClient">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionChallengeNonce">
            <summary>Proof of work challenge</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionChallengePOW">
            <summary>Proof of work challenge</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionPkixX509">
            <summary>PKIX Certificate</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionPkixOcsp">
            <summary>PKIX OCSP Token</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionMeshProfile">
            <summary>Mesh Profile</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionMeshConnection">
            <summary>Mesh Connection</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.Derive(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Using the primary key <paramref name="ikm"/> and generated nonce <paramref name="nonce"/>,
            derive key <paramref name="key"/> and initialization vector <paramref name="iv"/>.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="nonce">The generated nonce.</param>
            <param name="iv">The generated initialization vector.</param>
            <param name="key">The generated key.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.Derive2(System.Byte[],System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Using the primary key <paramref name="ikm"/> and provided nonce <paramref name="nonce"/>,
            derive key <paramref name="key"/> and initialization vector <paramref name="iv"/>.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="nonce">The nonce.</param>
            <param name="iv">The generated initialization vector.</param>
            <param name="key">The generated key.</param>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ZeroArray">
            <summary>Obsolete, remove</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PortId">
            <summary>
            Port identifier. Specifies an IP address and port number.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortId.IPAddress">
            <summary>The IP address.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortId.Port">
            <summary>The port number.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PortHistory">
            <summary>
            Port history. Used to track possible abuse.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.LastChallenge">
            <summary>Time at which the last challenge was issued.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.Challenges">
            <summary>Number of challenges issued.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.Refusals">
            <summary>Number of refusals made.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PortHistory.#ctor">
            <summary>
            Constructor, initialize the last challenge time to now.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.Listener">
            <summary>
            Listener class, process incoming packets and deliver responses to waiting tasks.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Listener.DictionaryIPAddressToHistory">
            <summary>Dictionary tracking inbound abuse by IP address</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Listener.DictionaryPortIdToHistory">
            <summary>Dictionary tracking inbound abuse by IP address and port</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Listener.DictionaryPortIdToConnection">
            <summary>Dictionary used for binding, maps connection Id to connection</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Listener.DictionaryIdToConnection">
            <summary>Dictionary used for rebinding, maps connection Id to connection</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Listener.HostCredential">
            <summary>The host credentials. There is exactly one set of host 
            credentials for a given PortId at a given time. This MAY however
            contain multiple keys (e.g. for different algorithms.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.#ctor(Goedel.Protocol.Presentation.PresentationCredential)">
            <summary>
            Constructor, create a new listener instance with the host credential 
            <paramref name="hostCredential"/>.
            </summary>
            <param name="hostCredential">The host credential.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.Open(System.String,System.String)">
            <summary>
            Attempt to establish a client connection to the host <paramref name="address"/> using
            protocol <paramref name="protocol"/>.
            </summary>
            <param name="protocol">The protocol specifier.</param>
            <param name="address">The host address.</param>
            <returns>Task which completes when the connection is established.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.Accept(System.String,System.String)">
            <summary>
            Accept inbound client connection requests on the port directed to the address
            <paramref name="address"/> using the protocol <paramref name="protocol"/>/
            </summary>
            <param name="protocol">The protocol specifier.</param>
            <param name="address">The host address.</param>
            <returns>Task which completes when the connection request is received.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.Process(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Process the data packet <paramref name="packet"/> received from the source
            <paramref name="sourceId"/>.
            </summary>
            <param name="sourceId">The packet source address.</param>
            <param name="packet">The packet data.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.Parse(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Parse a packet and retru
            </summary>
            <param name="sourceId">Identifier of the source from which the packet was received.</param>
            <param name="packet">The data packet.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.Packet">
            <summary>
            A Parsed Packet.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.Payload">
            <summary>The packet payload.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Packet.SourcePortId">
            <summary>The source address and port.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.ExtensionsPlaintext">
            <summary>Options specified in the packet plaintext.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.ExtensionsCiphertext">
            <summary>Options specified in the packet ciphertext.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.EncryptedPacketIdentifier">
            <summary>The inner data packet type.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Packet.#ctor(Goedel.Protocol.Presentation.PortId)">
            <summary>
            Constructor, return packet bound to port <paramref name="sourceId"/>.
            </summary>
            <param name="sourceId">The source address and port.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Packet.ReadEncrypted(Goedel.Protocol.Presentation.PacketReader)">
            <summary>
            Read an inner encrypted data packet from <paramref name="reader"/>.
            </summary>
            <param name="reader">Reader bound to the packet being read</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Packet.GetExtension(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.String)">
            <summary>
            Return the extension from the list <paramref name="extensions"/> with the 
            tag <paramref name="tag"/> if found, otherwise null.
            </summary>
            <param name="extensions">List of extensions to search.</param>
            <param name="tag">The tag to be matched.</param>
            <returns>The value portion of the matching tag.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketExtension">
            <summary>
            Packet options (to be specified).
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketExtension.Tag">
            <summary>Registered extension tag</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketExtension.Value">
            <summary>Extension value</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketUnknown">
            <summary>
            Unknown packet type.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketUnknown.#ctor(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Constructor, return packet bound to port <paramref name="sourceId"/> containing data
            <paramref name="data"/>.
            </summary>
            <param name="sourceId">The source address and port.</param>
            <param name="data">The packet data.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketData">
            <summary>
            Encrypted and authenticated data packet.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketData.#ctor(Goedel.Protocol.Presentation.PortId,Goedel.Protocol.Presentation.PacketReader)">
            <summary>
            Constructor, parse a decrypted data packet received from <paramref name="sourceId"/>
            bound to the reader <paramref name="reader"/>.
            </summary>
            <param name="sourceId">The packet source identifier.</param>
            <param name="reader">Reader for decrypted packet data.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketError">
            <summary>
            Error packet, MAY be returned in response to an unexpected request.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketError.ErrorCode">
            <summary>The returned error code.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketError.DestinationAddress">
            <summary>The address to which the packet was sent, i.e. the external
            port address of the recipient.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketError.#ctor(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Constructor, parse a plaintext data packet <paramref name="data"/> 
            received from <paramref name="sourceId"/>.
            </summary>
            <param name="sourceId">The packet source identifier.</param>
            <param name="data">The packet data.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketInitial">
            <summary>
            Initial packet, sent to obtain host information to begin connection establishment
            when the host credentials are not known.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketInitial.#ctor(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Constructor, parse a plaintext data packet <paramref name="data"/> 
            received from <paramref name="sourceId"/>.
            </summary>
            <param name="sourceId">The packet source identifier.</param>
            <param name="data">The packet data.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketClientExchange">
            <summary>
            Client exchange packet, establishes a channel encrypted to the host credential alone.
            It is not possible to authenticate to the client credential at this point as we do
            not have a host challenge.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketClientExchange.#ctor(Goedel.Protocol.Presentation.PortId,System.Byte[])">
            <summary>
            Constructor, for data packet
            received from <paramref name="sourceId"/>.
            </summary>
            <param name="sourceId">The packet source identifier.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketReader">
            <summary>
            Presentation packet reader class.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReader.Position">
            <summary>Reader position.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketReader.Packet">
            <summary>Buffer from which data is read.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.Factory(System.Byte[])">
            <summary>Factory method returning a reader of the default decryption algorithm and mode.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.#ctor(System.Byte[])">
            <summary>
            Constructor, returns a reader instance for the packet <paramref name="packet"/>.
            </summary>
            <param name="packet">The packet data.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadByte">
            <summary>
            Read the next byte in the packet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadSpan(System.Int32)">
            <summary>
            Return a Span containing the next <paramref name="length"/> bytes.
            </summary>
            <param name="length">The number of bytes to return.</param>
            <returns>The span.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadTag">
            <summary>
            Read a tag/length specifier from the stream.
            </summary>
            <returns>The tagged data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadInteger">
            <summary>
            Read an integer from the stream.
            </summary>
            <returns>The data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadBinarySpan">
            <summary>
            Read a binary from the stream.
            </summary>
            <returns>A span describing the data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadString">
            <summary>
            Read a UTF8 encoded string from the stream.
            </summary>
            <returns>The data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadExtensions">
            <summary>
            Read a list of extensions from <paramref name="reader"/>.
            </summary>
            <param name="reader">Reader bound to the packet being read</param>
            <returns>>The list of extensions read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.Decrypt(System.Byte[],System.Boolean)">
            <summary>
            Decrypt the remainder of the packet using the primary key <paramref name="ikm"/> and the 
            nonce at the current position in the packet to provide the necessary keying material.
            </summary>
            <param name="ikm">The primary key.</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.Unwrap(System.Byte[],System.Byte[])">
            <summary>
            Unwrap the packet <paramref name="packet"/> using  the primary key <paramref name="ikm"/> and 
            the nonce at the start of the packet to provide the necessary keying material.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="packet">The data to decrypt</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketReaderAesGcm">
            <summary>
            Packet reader using AES in GCM mode for decryption.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReaderAesGcm.SizeIv">
            <summary>Initialization vector size in bytes. Currently fixed at 12 bytes.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReaderAesGcm.SizeTag">
            <summary>Tag size in bytes. Currently fixed at 16 bytes.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.#ctor(System.Byte[])">
            <summary>
            Constructor, returns a reader instance for the packet <paramref name="packet"/>.
            </summary>
            <param name="packet">The packet data.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.Decrypt(System.Byte[],System.Boolean)">
            <summary>
            Decrypt the remainder of the packet using the primary key <paramref name="key"/> and the 
            nonce at the current position in the packet to provide the necessary keying material.
            </summary>
            <param name="key">The primary key.</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.Unwrap(System.Byte[],System.Byte[])">
            <summary>
            Unwrap the packet <paramref name="packet"/> using  the primary key <paramref name="key"/> and 
            the nonce at the start of the packet to provide the necessary keying material.
            </summary>
            <param name="key">The primary key.</param>
            <param name="packet">The data to decrypt</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketTag">
            <summary>
            Packet tag types
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Integer">
            <summary>Integer field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.String">
            <summary>String field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Binary">
            <summary>Binary field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Extensions">
            <summary>List of extensions follow</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketWriter">
            <summary>
            Base class for packet writers.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketWriter.Position">
            <summary>Position of the writer within the packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketWriter.Packet">
            <summary>The Packet data</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Factory(System.Int32)">
            <summary>Factory method, returns a packet writer for the default encryption algorithm.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.#ctor(System.Int32)">
            <summary>
            Constructor, create a packet writer with a packet size of 
            <paramref name="packetSize"/>.
            </summary>
            <param name="packetSize">The number of bytes in the packet to be created.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.LengthLength(System.Int64)">
            <summary>
            Return the number of bytes taken to specify tag/length production of length
            <paramref name="data"/>.
            </summary>
            <param name="data">The data item to size.</param>
            <returns>Number of bytes required for the encoding.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte)">
            <summary>
            Write a byte to the packet
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.WriteTag(Goedel.Protocol.Presentation.PacketTag,System.Int64)">
            <summary>
            Write out a Tag-Length value using the shortest possible production.
            </summary>
            <param name="tag">Base code.</param>
            <param name="data">Length of data to follow.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Int32)">
             <summary>
            Write the positive integer <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte[])">
            <summary>
            Write the binary data <paramref name="data"/> to the packet.
            </summary>
            <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Write the binary data  <paramref name="data"/> to the packet beginning
             at position <paramref name="offset"/> for <paramref name="count"/> bytes.
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.String)">
             <summary>
            Write the string <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(Goedel.Protocol.Presentation.EncryptedPacketIdentifier)">
             <summary>
            Write the positive EncryptedPacketIdentifier <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(Goedel.Protocol.Presentation.PlaintextPacketType)">
             <summary>
            Write the positive EncryptedPacketIdentifier <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.SkipBinary(System.Int32)">
            <summary>
            Skip forward to reserve space for a data item of <paramref name="length"/>
            bytes.
            </summary>
            <param name="length">Length of the data item to reserve space for.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Encrypt(System.Byte[],Goedel.Protocol.Presentation.PacketWriter,System.Boolean)">
            <summary>
            Fill out the remainder of the packet by using the value <paramref name="ikm"/>
            and a generated nonce to encrypt the data specified in <paramref name="packet"/>
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="packet">The plaintext data</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Wrap(System.Byte[])">
            <summary>
            Wrap a data packet payload to create an encrypted data packet.
            </summary>
            <param name="ikm">The primary key.</param>
            <returns>The wrapped data packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketWriterAesGcm">
            <summary>
            Encrypting packet writer.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.#ctor(System.Int32)">
            <summary>
            Constructor, create a packet writer with a packet size of 
            <paramref name="packetSize"/>.
            </summary>
            <param name="packetSize">The number of bytes in the packet to be created.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.Encrypt(System.Byte[],Goedel.Protocol.Presentation.PacketWriter,System.Boolean)">
            <summary>
            Fill out the remainder of the packet by using the value <paramref name="key"/>
            and a generated nonce to encrypt the data specified in <paramref name="writerIn"/>
            </summary>
            <param name="key">The primary key.</param>
            <param name="writerIn">The plaintext data</param>
            <param name="pad">If true, pad packet to fill remaining space.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.Wrap(System.Byte[])">
            <summary>
            Wrap a data packet payload to create an encrypted data packet.
            </summary>
            <param name="key">The primary key.</param>
            <returns>The wrapped data packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PresentationCredential">
            <summary>
            Base class for presentation credential
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PresentationCredential.KeySignPrivate">
            <summary>The signature key to sign under the credential.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PresentationCredential.KeyExchangePrivate">
            <summary>The private key exchange key.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PresentationCredential.KeySignPublic">
            <summary>The signature verification key under the credential</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PresentationCredential.KeyExchangePublic">
            <summary>The public key exchange key.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PresentationCredential.GetCredentials">
            <summary>List of extension entries presenting credentials.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PresentationCredential.WriteClientCredential(Goedel.Protocol.JsonWriter)">
            <summary>
            Obsolete, to be removed.
            </summary>
            <param name="jsonWriter"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PresentationCredential.WriteCredential(Goedel.Protocol.Presentation.PacketWriter)">
            <summary>
            Write credential type specifier and credential to packet.
            </summary>
            <param name="writer">The packet writer</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PresentationCredential.GetEphemeral">
            <summary>
            Return a (public, private) key pair that can be used to perform a key exchange
            from the credential key exchange key(s) and the ephemeral keys presented in the
            list of extensions <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions specifying an ephemeral key.</param>
            <returns>The key exchange parameters (if found).</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PresentationCredential.MatchEphemeral(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Return a (public, private) key pair that can be used to perform a key exchange
            from the credential key exchange key(s) and the ephemeral keys presented in the
            list of extensions <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions specifying an ephemeral key.</param>
            <returns>The key exchange parameters (if found).</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PresentationCredential.MatchEphemeral(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.String)">
            <summary>
            Return a (public, private) key pair that can be used to perform a key exchange
            from the credential key exchange key(s) and the ephemeral keys presented in the
            list of extensions <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions specifying an ephemeral key.</param>
            <returns>The key exchange parameters (if found).</returns>
        </member>
        <member name="T:Goedel.Protocol.PacketSizeExceeded">
            <summary>
            The packet was too small to contain the data
            </summary>
        </member>
        <member name="P:Goedel.Protocol.PacketSizeExceeded.ExceptionFormatDelegate">
            <summary>The exception formatting delegate. May be overriden 
            locally or globally to implement different exception formatting.</summary>
        </member>
        <member name="F:Goedel.Protocol.PacketSizeExceeded.Templates">
            <summary>Templates for formatting response messages.</summary>
        </member>
        <member name="M:Goedel.Protocol.PacketSizeExceeded.#ctor(System.String,System.Exception,System.Object[])">
            <summary>
            Construct instance for exception
            </summary>		
            <param name="description">Description of the error, may be used to override the 
            generated message.</param>	
            <param name="inner">Inner Exception</param>	
            <param name="args">Optional list of parameterized arguments.</param>
        </member>
        <member name="M:Goedel.Protocol.PacketSizeExceeded._Throw(System.Object)">
            <summary>
            The public fatory delegate
            </summary>
            public static global::Goedel.Utilities.ThrowNewDelegate ThrowNew = _Throw;
        </member>
        <member name="F:Goedel.Protocol.PacketSizeExceeded.Throw">
            <summary>
            The public fatory delegate
            </summary>
        </member>
        <member name="T:Goedel.Protocol.InvalidClientState">
            <summary>
            The client is in an invalid state for the requested operation.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.InvalidClientState.ExceptionFormatDelegate">
            <summary>The exception formatting delegate. May be overriden 
            locally or globally to implement different exception formatting.</summary>
        </member>
        <member name="F:Goedel.Protocol.InvalidClientState.Templates">
            <summary>Templates for formatting response messages.</summary>
        </member>
        <member name="M:Goedel.Protocol.InvalidClientState.#ctor(System.String,System.Exception,System.Object[])">
            <summary>
            Construct instance for exception
            </summary>		
            <param name="description">Description of the error, may be used to override the 
            generated message.</param>	
            <param name="inner">Inner Exception</param>	
            <param name="args">Optional list of parameterized arguments.</param>
        </member>
        <member name="M:Goedel.Protocol.InvalidClientState._Throw(System.Object)">
            <summary>
            The public fatory delegate
            </summary>
            public static global::Goedel.Utilities.ThrowNewDelegate ThrowNew = _Throw;
        </member>
        <member name="F:Goedel.Protocol.InvalidClientState.Throw">
            <summary>
            The public fatory delegate
            </summary>
        </member>
    </members>
</doc>

<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Goedel.Protocol.Presentation</name>
    </assembly>
    <members>
        <member name="T:Goedel.Protocol.Presentation.Connection">
            <summary>
            Base class for presentation connections.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.SourceIdSize">
            <summary>The size of a source ID tag.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.PacketQuanta">
            <summary>Packet Quantization</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ClientKeyClientToHost">
            <summary>Symmetric key used to encrypt/decrypt mezzanine data sent by the client to 
            the host.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ClientKeyHostToClient">
            <summary>Symmetric key used to encrypt/decrypt mezzanine data sent by the host to 
            the client.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.MutualKeyClientToHost">
            <summary>Symmetric key used to encrypt/decrypt inner data sent by the client to 
            the host.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.MutualKeyHostToClient">
            <summary>Symmetric key used to encrypt/decrypt inner data sent by the host to 
            the client.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ClientKeyIn">
            <summary>Symmetric key used to decrypt received mezzanine data.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ClientKeyOut">
            <summary>Symmetric key used to encrypt sent mezzanine data.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.MutualKeyIn">
            <summary>Symmetric key used to decrypt received inner data.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.MutualKeyOut">
            <summary>Symmetric key used to encrypt sent inner data.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.CredentialOther">
            <summary>Public credential of the counter party.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.CredentialSelf">
            <summary>Private credential of self.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.HostCredential">
            <summary>The host credential</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.ClientCredential">
            <summary>The client credential</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.PacketIn">
            <summary>The packet that the connection is a response to.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.LocalStreamId">
            <summary>The local stream Id, this is generated localy and MAY contain hidden structure.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Connection.RemoteStreamId">
            <summary>Remote stream Id, an opaque blob.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Connection.ReturnStreamId">
            <summary>When not null, contains the return address to be sent as an an extension.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.AddEphemerals(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Generate a set of ephemerals for the supported algorithms to offer for 
            key agreement and add to <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
            <param name="sourceId">The source identifier assigned to the return packet.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.AddCredentials(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add the credentials specified in <see cref="P:Goedel.Protocol.Presentation.Connection.CredentialSelf"/> to 
            <paramref name="extensions"/>
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.AddChallenge(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add a challenge value over the current state to <paramref name="extensions"/>
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.AddResponse(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add a response value over the current state to <paramref name="extensions"/>
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.QuantizePacketLength(System.Int32)">
            <summary>
            Quantize the packet length so it is a fixed multiple of 64 bits.
            </summary>
            <param name="length">The minimum length to return.</param>
            <returns>The Quantized length.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.SerializePacketData(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Int32,System.Byte[],System.Int32,System.Byte[])">
            <summary>
            Serialize and mutually encrypt a data packet.
            </summary>
            <param name="destinationStream">The remote stream identifier.</param>
            <param name="payload"></param>
            <param name="ciphertextExtensions"></param>
            <param name="packetSize">The number of bytes in the packet to be created.</param>
            <param name="buffer">Optional buffer passed in for use by the method.</param>
            <param name="position">Start point for writing to the buffer.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ParsePacketData(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the data in <paramref name="packet"/> and return the resulting packet.
            </summary>
            <param name="packet">The encrypted packet</param>
            <param name="offset">Offset at which to begin reading.</param>
            <param name="last">Last byte in the buffer to parse.</param>
            <returns>Packet specifying the decrypted payload and extensions (if specified).</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(Goedel.Cryptography.KeyPairAdvanced,Goedel.Cryptography.KeyPairAdvanced)">
            <summary>
            Perform a key exchange to the host credential only. 
            </summary>
            <param name="privateKey">The private key</param>
            <param name="keyPublic">The public key.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(System.String@)">
            <summary>
            Perform a client key exchange to the host credential using an ephemeral chosen from the
            set of ephemerals chosen by the client.
            </summary>
            <param name="keyId">Host key identifier</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(System.Byte[],System.String)">
            <summary>
            Perform a client key exchange to the host credential using the ephemeral chosen by the
            client.
            </summary>
            <param name="ephemeral"></param>
            <param name="keyId"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(System.String)">
            <summary>
            Perform a client key exchange to the key <paramref name="keyId"/> using the first compatible 
            ephemeral previously offered.
            </summary>
            <param name="keyId">Host key identifier</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.ClientKeyExchange(System.Byte[]@,System.String@)">
            <summary>
            Perform a client key exchange to the host credential selecting a key and generating a
            compatible ephemeral returned as <paramref name="ephemeral"/>.
            </summary>
            <param name="ephemeral">The ephemeral generated.</param>
            <param name="keyId">Host key identifier</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(Goedel.Cryptography.KeyPairAdvanced,Goedel.Cryptography.KeyPairAdvanced)">
            <summary>
            Complete a mutual key exchange to the client credential and previous client exchange. 
            </summary>
            <param name="privateKey">The private key</param>
            <param name="keyPublic">The public key.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(System.String@)">
            <summary>
            Complete a mutual key exchange to the client credential using an ephemeral chosen from the
            set of nonces chosen by the host to complete a mutual key exchange.
            </summary>
            <param name="keyId">Client key identifier</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(System.Byte[],System.String)">
            <summary>
            Complete a mutual key exchange to the host credential using the ephemeral chosen by the
            host.
            </summary>
            <param name="ephemeral"></param>
            <param name="keyId"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(System.String)">
            <summary>
            Complete a mutual key exchange to the key <paramref name="keyId"/> using the first compatible 
            ephemeral previously offered.
            </summary>
            <param name="keyId">Host key identifier</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Connection.MutualKeyExchange(System.Byte[]@,System.String@)">
            <summary>
            Complete a mutual key exchange to the client credential selecting a key and generating a
            compatible ephemeral returned as <paramref name="ephemeral"/> to complete a 
            mutual key exchange..
            </summary>
            <param name="ephemeral">The ephemeral generated.</param>
            <param name="keyId">Client key identifier</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ConnectionInitiator">
            <summary>
            Presentation client connection. Tracks the state of a client connection.
            </summary>
            <summary>
            Client connection class. Tracks the state of a client connection.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.ClientKeyIn">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.ClientKeyOut">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.MutualKeyIn">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.MutualKeyOut">
            <inheritdoc/> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.HostCredential">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.ClientCredential">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.VerifiedAccount">
            <summary>The verified account.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.Domain">
            <summary>The connection domain.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.Connected">
            <summary>If true, the connection is connected to the remote endpoint.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionInitiator.ObjectEncoding">
            <summary>The object encoding for use in the connection</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ConnectionInitiator.PacketChallenge">
            <summary>Reusable packet challenge</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.Disposing">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.GetClient``1(Goedel.Protocol.Presentation.Credential)">
            <summary>
            Return a client bound to the connection via the relevant protocol
            </summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.SerializeClientInitial(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type ClientInitial packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.SerializeClientExchange(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type ClientExchange packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="mezanineExtensionsIn">Additional extensions to be presented
            in the mezzanine segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.SerializeClientComplete(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type ClientComplete packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="mezanineExtensionsIn">Additional extensions to be presented
            in the mezzanine segment.</param>
            <param name="ciphertextExtensions">Additional extensions to be presented 
            in the encrypted segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.SerializeClientCompleteDeferred(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type ClientCompleteDeferred packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="mezanineExtensionsIn">Additional extensions to be presented
            in the mezzanine segment.</param>
            <param name="ciphertextExtensions">Additional extensions to be presented 
            in the encrypted segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.ParseHostExchange(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a HostExchange packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.ParseHostChallenge1(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a HostChallenge1 packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.ParseHostChallenge2(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a HostChallenge2 packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionInitiator.ParseHostComplete(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a HostComplete packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PlaintextPacketType">
            <summary>
            The packet types passed as plaintext. This is actually redundant as far as the 
            specification goes as these are now at the option of the sender.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientInitial">
            <summary>Plaintext request to establish a new connection to the host. This is 
            only used in cases where the client does not have the public key of the host.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Data">
            <summary>Data packet (for internal use).</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Error">
            <summary>Report an error to the sender.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientExchange">
            <summary>Encrypted request to establish a new connection to the host.
            This MAY be used in cases where the client has the public key of the host.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientComplete">
            <summary>Client completion of key exchange.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.ClientCompleteDeferred">
            <summary>Client completion of key exchange.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostChallenge">
            <summary>Present a challenge to a client requesting a connection.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostExchange">
            <summary>Present a challenge to a client requesting a connection.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.HostComplete">
            <summary>Host completion of key exchange.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PlaintextPacketType.Rebind">
            <summary>Establish a new binding for the specified connection identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.ErrorCode">
            <summary>
            Error response codes.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCode.UnknownConnection">
            <summary>The request could not be bound to an inbound connection. This could be because
            the source address has changed.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCode.Refused">
            <summary>The request was refused for reasons reserved to the responder.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.Constants">
            <summary>
            Constants class
            </summary>
            <summary>
            Constants specified in hallambaker-mesh-schema
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.MinimumPacketSize">
            <summary>The minimum packet size.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeReservedInitialStreamId">
            <summary>The number of bytes reserved for the initial stream identifier (all zeros)</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeNonceAesGcm">
            <summary>Size of packet nonce to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeIvAesGcm">
            <summary>Size of initialization vector / AES nonce to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeTagAesGcm">
            <summary>Size of authentication tag to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.SizeKeyAesGcm">
            <summary>Size of key to be used in AES-GCM packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagIv">
            <summary>The KDF info tag to be used to derive initialization vectors.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKey">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.StreamIdClientInitial">
            <summary>Fixed constant containing the reserved client initial stream identifier.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ByteKeyInitiatorResponder">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ByteKeyResponderInitiator">
            <summary>The KDF info tag to be used to derive keys.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionChallengeNonce">
            <summary>Proof of work challenge</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionChallengePOW">
            <summary>Proof of work challenge</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionPkixX509">
            <summary>PKIX Certificate</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionPkixOcsp">
            <summary>PKIX OCSP Token</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionMeshProfile">
            <summary>Mesh Profile</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ExtensionMeshConnection">
            <summary>Mesh Connection</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagHostExchange">
            <summary></summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagHostChallenge1">
            <summary></summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagHostChallenge2">
            <summary></summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagHostComplete">
            <summary></summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.Derive(System.Byte[],System.Byte[]@,System.Byte[]@,System.Byte[]@)">
            <summary>
            Using the primary key <paramref name="ikm"/> and generated nonce <paramref name="nonce"/>,
            derive key <paramref name="key"/> and initialization vector <paramref name="iv"/>.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="nonce">The generated nonce.</param>
            <param name="iv">The generated initialization vector.</param>
            <param name="key">The generated key.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.Derive2(System.Byte[],System.Byte[],System.Byte[]@,System.Byte[]@)">
            <summary>
            Using the primary key <paramref name="ikm"/> and provided nonce <paramref name="nonce"/>,
            derive key <paramref name="key"/> and initialization vector <paramref name="iv"/>.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="nonce">The nonce.</param>
            <param name="iv">The generated initialization vector.</param>
            <param name="key">The generated key.</param>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ZeroArray">
            <summary>Obsolete, remove</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToClientInitial(System.String)">
            <summary>
            Convert the string <paramref name="text"/> to the corresponding enumeration
            value.
            </summary>
            <param name="text">The string to convert.</param>
            <returns>The enumeration value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToLabel(Goedel.Protocol.Presentation.ClientInitial)">
            <summary>
            Convert the enumerated value <paramref name="data"/> to the corresponding string
            value.
            </summary>
            <param name="data">The enumerated value.</param>
            <returns>The text value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToHostMessageTags(System.String)">
            <summary>
            Convert the string <paramref name="text"/> to the corresponding enumeration
            value.
            </summary>
            <param name="text">The string to convert.</param>
            <returns>The enumeration value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToLabel(Goedel.Protocol.Presentation.HostMessageTags)">
            <summary>
            Convert the enumerated value <paramref name="data"/> to the corresponding string
            value.
            </summary>
            <param name="data">The enumerated value.</param>
            <returns>The text value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToErrorCodes(System.String)">
            <summary>
            Convert the string <paramref name="text"/> to the corresponding enumeration
            value.
            </summary>
            <param name="text">The string to convert.</param>
            <returns>The enumeration value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToLabel(Goedel.Protocol.Presentation.ErrorCodes)">
            <summary>
            Convert the enumerated value <paramref name="data"/> to the corresponding string
            value.
            </summary>
            <param name="data">The enumerated value.</param>
            <returns>The text value.</returns>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKeyInitiatorResponder">
            <summary>InitiatorResponder</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.TagKeyResponderInitiator">
            <summary>ResponderInitiator</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.ProtocolIdRud">
            <summary>RUD</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.Constants.StreamId">
            <summary>SID</summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToExtensionTags(System.String)">
            <summary>
            Convert the string <paramref name="text"/> to the corresponding enumeration
            value.
            </summary>
            <param name="text">The string to convert.</param>
            <returns>The enumeration value.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Constants.ToLabel(Goedel.Protocol.Presentation.ExtensionTags)">
            <summary>
            Convert the enumerated value <paramref name="data"/> to the corresponding string
            value.
            </summary>
            <param name="data">The enumerated value.</param>
            <returns>The text value.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.Credential">
            <summary>
            Base class for presentation credentials.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.AddEphemerals(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Cryptography.KeyPairAdvanced}@)">
            <summary>
            Generate a set of ephemerals for the supported algorithms to offer for 
            key agreement and add to <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
            <param name="ephmeralsOffered">List of ephemerals that have been offered, if
            this is not null, the ephemerals in this list will be returned. Otherwise a list
            will be created and populated with the ephemerals offered.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.AddCredentials(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add an extension containing this credential to <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions to add the credential to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.GetCredentials(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add an extension containing this credential to <paramref name="extensions"/>.
            </summary>
            <param name="extensions">List of extensions to add the credential to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.SelectKey(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Select a private key compatible with the ephemeral keys offered in 
            <paramref name="extensions"/> and return the private key and ephemeral
            chosen.
            </summary>
            <param name="extensions">List of extensions offering ephemeral keys to
            perform a key agreement against.</param>
            <returns>The private key and public key.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.SelectKey(System.String,System.Byte[])">
            <summary>
            Return a private key and public key compatible with the values specified
            by <paramref name="keyId"/> and <paramref name="ephemeral"/>.
            chosen.
            </summary>
            <param name="keyId">The key identifier.</param>
            <param name="ephemeral">Ephemeral data specifying a public key </param>
            <returns>The ephemeral private key and credential public key.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.SelectKey">
            <summary>
            Return a private ephemeral key and compatible public key from the 
            credential keys
            </summary>
            <returns>The ephemeral private key and credential public key.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Credential.SelectKey(System.Collections.Generic.List{Goedel.Cryptography.KeyPairAdvanced},System.String)">
            <summary>
            Select an ephemeral from <paramref name="ephemerals"/> that is compatible with 
            the creedential key <paramref name="keyId"/>.
            </summary>
            <param name="keyId">If specified, the first ephemeral in the list compatible
            with the specified key will be used.</param> 
            <param name="ephemerals">List of ephemerals previously offered to
            perform a key agreement against.</param>
            <returns>The ephemeral private key and credential public key.</returns>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PresentationType.Http">
            <summary>HTTP/Fred binding.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PresentationType.Udp">
            <summary>UDP/Fred binding.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PresentationType.All">
            <summary>All supported provider types.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.Endpoint">
            <summary>
            Record describing a listener endpoint.
            </summary>
            <param name="Protocol">Directory to store persistence data.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Endpoint.#ctor(System.String,System.String)">
            <summary>
            Record describing a listener endpoint.
            </summary>
            <param name="Protocol">Directory to store persistence data.</param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PortId">
            <summary>
            Port identifier. Specifies an IP address and port number.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortId.IPAddress">
            <summary>The IP address.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortId.Port">
            <summary>The port number.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PortHistory">
            <summary>
            Port history. Used to track possible abuse.
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.LastChallenge">
            <summary>Time at which the last challenge was issued.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.Challenges">
            <summary>Number of challenges issued.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PortHistory.Refusals">
            <summary>Number of refusals made.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PortHistory.#ctor">
            <summary>
            Constructor, initialize the last challenge time to now.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.Listener">
            <summary>
            Base class for presentation listeners.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.Listener.CredentialSelf">
            <summary>Private credential of self.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Listener.DictionarySessionsInbound">
            <summary>Dictionary mapping inbound source Ids to sessions.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.#ctor(Goedel.Protocol.Presentation.Credential)">
            <summary>
            Base constructor, populate the common properties.
            </summary>
            <param name="credentialSelf">The credential used by the listener.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.MakeChallenge(Goedel.Protocol.Presentation.Packet,System.Byte[])">
            <summary>
            Create a challenge value over the packet <paramref name="packetRequest"/> and
            payload <paramref name="payload"/> and return as a list of packet extensions.
            </summary>
            <param name="packetRequest">The packet request.</param>
            <param name="payload">The payload.</param>
            <returns>List of challenge tokens.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.VerifyChallenge(Goedel.Protocol.Presentation.Packet)">
            <summary>
            Verify the challenge data in <paramref name="packetRequest"/> returning true if
            verification succeeds, false otherwise.
            </summary>
            <param name="packetRequest">The packet to be validated.</param>
            <returns>True if challenge was valid, otherwise false.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.Accept(Goedel.Protocol.Presentation.Packet)">
            <summary>
            Accept the inbound connection request described in <paramref name="packetRequest"/>.
            </summary>
            <param name="packetRequest">Parsed inbound request packet.</param>
            <returns>The host connection. This may be used to wait for inbound requests from the 
            connection.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.GetTemporaryResponder(Goedel.Protocol.Presentation.Packet)">
            <summary>
            Defer creation of a host connection by sending a challenge to the source.
            </summary>
            <param name="packetRequest">Parsed inbound request packet.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.ParseClientInitial(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a ClientInitial packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.ParseClientExchange(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a ClientExchange packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.ParseClientComplete(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a ClientComplete packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.Listener.ParseClientCompleteDeferred(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Parse the packet <paramref name="packet"/> as a ClientCompleteDeferred packet.
            </summary>
            <param name="packet">The packet data</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.
            If less than 0, <paramref name="packet"/> is read to the end.</param>
            <returns>The parsed packet.</returns>
        </member>
        <member name="F:Goedel.Protocol.Presentation.MeshSessionResponder.SourceId">
            <summary>The source Id to be used by this responder when returning packets.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.MeshSessionResponder.AddChallenge(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Add a challenge value over the current state to <paramref name="extensions"/>
            </summary>
            <param name="extensions">List of extensions to add the ephemerals to.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.MeshSessionResponder.#ctor(Goedel.Protocol.Presentation.Listener,Goedel.Protocol.Presentation.Packet)">
            <summary>
            Constructor, create a responder connection for <paramref name="listener"/>
            </summary>
            <param name="listener">The listener managing the connection.</param>
            <param name="packetIn">The received packet.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.MeshSessionResponder.AddEphemerals(System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.MeshSessionResponder.MutualKeyExchange(System.String)">
            <inheritdoc/>
        </member>
        <member name="T:Goedel.Protocol.Presentation.NamespaceDoc">
            <summary>
            Support library for FRED presentation layer.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketExtension">
            <summary>
            Packet options (to be specified).
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketExtension.Tag">
            <summary>Registered extension tag</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketExtension.Value">
            <summary>Extension value</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketExtension.GetExtensionByTag(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.String)">
            <summary>
            Convenience method scans the list <paramref name="packetExtensions"/> and returns the
            first matching the tag <paramref name="PrimaryTag"/>.
            </summary>
            <param name="packetExtensions">The extensions to scan. If this is a null pointer the
            null value is returned.</param>
            <param name="PrimaryTag">The tag to find.</param>
            <returns>The first value matching the specified tag if found, otherwise null.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketExtension.Dump">
            <summary>
            Debug routine, print the tag value to the screen.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.Packet">
            <summary>
            Base class for packet classes.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.Payload">
            <summary>The packet payload.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.Packet.SourceId">
            <summary>The source address and port.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.Packet.PlaintextExtensions">
            <summary>Options specified in the packet plaintext.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.Packet.Dump">
            <summary>
            Debug output, remove for final release.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketData">
            <summary>
            Packet data exchanged after negotiation has been completed.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketData.CiphertextExtensions">
            <summary>Options specified in the packet ciphertext.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketReader">
            <summary>
            Presentation packet reader class.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReader.Position">
            <summary>Reader position.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketReader.Last">
            <summary>The length of the valid portion of the buffer <see cref="T:System.Buffer"/>.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketReader.Packet">
            <summary>Buffer from which data is read. This MAY be longer than needed, the lenght to be used
            is specified by <see cref="F:Goedel.Protocol.Presentation.PacketReader.Last"/></summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.Factory(System.Byte[])">
            <summary>Factory method returning a reader of the default decryption algorithm and mode.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
            Constructor, returns a reader instance for the packet <paramref name="packet"/>.
            </summary>
            <param name="packet">The packet data.</param>
            <param name="position">Start position at which reading of the packet should start.</param>
            <param name="count">Maximum number of bytes to be read from <paramref name="packet"/>.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadByte">
            <summary>
            Read the next byte in the packet.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadSpan(System.Int32)">
            <summary>
            Return a Span containing the next <paramref name="length"/> bytes.
            </summary>
            <param name="length">The number of bytes to return.</param>
            <returns>The span.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadTag">
            <summary>
            Read a tag/length specifier from the stream.
            </summary>
            <returns>The tagged data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadInteger">
            <summary>
            Read an integer from the stream.
            </summary>
            <returns>The data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadBinarySpan">
            <summary>
            Read binary from the stream and return as a span.
            </summary>
            <returns>A span containing the data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadString">
            <summary>
            Read a UTF8 encoded string from the stream.
            </summary>
            <returns>The data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadBinary">
            <summary>
            Read binary from the stream and return as a byte array.
            </summary>
            <returns>A byte array containing the data that was read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.ReadExtensions">
            <summary>
            Read a list of extensions.
            </summary>
            <returns>>The list of extensions read.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReader.Decrypt(System.Byte[],System.Boolean)">
            <summary>
            Decrypt the remainder of the packet using the primary key <paramref name="ikm"/> and the 
            nonce at the current position in the packet to provide the necessary keying material.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="pad">If true the data is padded to consume the remainder of the data.</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketReaderAesGcm">
            <summary>
            Packet reader using AES in GCM mode for decryption.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReaderAesGcm.SizeIv">
            <summary>Initialization vector size in bytes. Currently fixed at 12 bytes.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketReaderAesGcm.SizeTag">
            <summary>Tag size in bytes. Currently fixed at 16 bytes.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.#ctor(System.Byte[],System.Int32,System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.Decrypt(System.Byte[],System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketReaderAesGcm.Unwrap(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>
            Unwrap the packet <paramref name="packet"/> using  the primary key <paramref name="key"/> and 
            the nonce at the start of the packet to provide the necessary keying material.
            </summary>
            <param name="key">The primary key.</param>
            <param name="packet">The data to decrypt</param>
            <param name="offset">The starting point of the encrypted portion of the buffer (i.e. start
            of the initialization vector)</param>
            <param name="last">The last byte in the buffer to read.</param>
            <returns>A reader for the decrypted data.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ConnectionResponder">
            <summary>
            Presentation host connection. Tracks the state of a host connection.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.SerializeHostExchange(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type HostExchange packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="mezanineExtensionsIn">Additional extensions to be presented
            in the mezzanine segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.SerializeHostChallenge1(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type HostChallenge1 packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.SerializeHostChallenge2(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type HostChallenge2 packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.SerializeHostComplete(System.Byte[],System.Byte[],System.Byte[],System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension},System.Byte[],System.Int32)">
            <summary>
            Create a serialised packet of type HostComplete packet.
            </summary>
            <param name="sourceId">The source identifier.</param>
            <param name="destinationId">The destination identifier.</param>
            <param name="payload">The payload data.</param>
            <param name="plaintextExtensionsIn">Additional extensions to be presented 
            in the plaintext segment.</param>
            <param name="mezanineExtensionsIn">Additional extensions to be presented
            in the mezzanine segment.</param>
            <param name="ciphertextExtensions">Additional extensions to be presented 
            in the encrypted segment.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
            <returns>The serialized data.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.CompleteClientComplete(Goedel.Protocol.Presentation.PacketClientComplete)">
            <summary>
            Perform key exchanges and complete parsing of the packet
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.CompleteClientCompleteDeferred(Goedel.Protocol.Presentation.PacketClientCompleteDeferred)">
            <summary>
            Perform key exchanges and complete parsing of the packet
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.ClientKeyIn">
            <inheritdoc/> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.ClientKeyOut">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.MutualKeyIn">
            <inheritdoc/> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.MutualKeyOut">
            <inheritdoc/>
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.HostCredential">
            <inheritdoc/> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.ClientCredential">
            <inheritdoc/> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.ConnectionResponder.Listener">
            <summary>The listener this connection host services</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.#ctor(Goedel.Protocol.Presentation.Listener)">
            <summary>
            Constructor for a connection host instance connected to <paramref name="listener"/>
            </summary>
            <param name="listener">The listener this connection is to service.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.Receive">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.ConnectionResponder.Reply(System.Byte[])">
            <summary>
            
            </summary>
            <param name="payload"></param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketClientInitial">
            <summary>
            Parsed ClientInitial packet
            </summary>   
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketClientExchange">
            <summary>
            Parsed ClientExchange packet
            </summary>   
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientExchange.Reader">
            <summary>Packet reader used to complete reading of the packet.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientExchange.MezzanineExtensions">
            <summary>Options specified in the packet mezzanine.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientExchange.ClientEphemeral">
            <summary>Host chosen ephemeral key.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientExchange.HostKeyId">
            <summary>Client Key Identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketClientComplete">
            <summary>
            Parsed ClientComplete packet
            </summary>   
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientComplete.Reader">
            <summary>Packet reader used to complete reading of the packet.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientComplete.MezzanineExtensions">
            <summary>Options specified in the packet mezzanine.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientComplete.CiphertextExtensions">
            <summary>Options specified in the packet ciphertext.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientComplete.ClientKeyId">
            <summary>Host Key Identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketClientCompleteDeferred">
            <summary>
            Parsed ClientCompleteDeferred packet
            </summary>   
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.Reader">
            <summary>Packet reader used to complete reading of the packet.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.MezzanineExtensions">
            <summary>Options specified in the packet mezzanine.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.CiphertextExtensions">
            <summary>Options specified in the packet ciphertext.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.ClientEphemeral">
            <summary>Host chosen ephemeral key.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.HostKeyId">
            <summary>Client Key Identifier.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketClientCompleteDeferred.ClientKeyId">
            <summary>Host Key Identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketHostExchange">
            <summary>
            Parsed HostExchange packet
            </summary>   
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostExchange.MezzanineExtensions">
            <summary>Options specified in the packet mezzanine.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostExchange.HostKeyId">
            <summary>Client Key Identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketHostChallenge1">
            <summary>
            Parsed HostChallenge1 packet
            </summary>   
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketHostChallenge2">
            <summary>
            Parsed HostChallenge2 packet
            </summary>   
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketHostComplete">
            <summary>
            Parsed HostComplete packet
            </summary>   
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostComplete.MezzanineExtensions">
            <summary>Options specified in the packet mezzanine.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostComplete.CiphertextExtensions">
            <summary>Options specified in the packet ciphertext.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostComplete.HostEphemeral">
            <summary>Client chosen ephemeral key.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketHostComplete.ClientKeyId">
            <summary>Host Key Identifier.</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketTag">
            <summary>
            Packet tag types
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Integer">
            <summary>Integer field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.String">
            <summary>String field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Binary">
            <summary>Binary field</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketTag.Extensions">
            <summary>List of extensions follow</summary> 
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketWriter">
            <summary>
            Base class for packet writers.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketWriter.Position">
            <summary>Position of the writer within the packet.</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.PacketWriter.Packet">
            <summary>The Packet data</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketWriter.RemainingSpace">
            <summary>Size of the largest encrypted block that can be inserted into
            the writer.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Factory(System.Int32)">
            <summary>Factory method, returns a packet writer for the default encryption algorithm.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.#ctor(System.Int32,System.Byte[],System.Int32)">
            <summary>
            Constructor, create a packet writer with a packet size of 
            <paramref name="packetSize"/>.
            </summary>
            <param name="packetSize">The number of bytes in the packet to be created.</param>
            <param name="buffer">Buffer provided by caller</param>
            <param name="position">Offset within packet at which first byte is to be written.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.LengthLength(System.Int64)">
            <summary>
            Return the number of bytes taken to specify tag/length production of length
            <paramref name="data"/>.
            </summary>
            <param name="data">The data item to size.</param>
            <returns>Number of bytes required for the encoding.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte)">
            <summary>
            Write a byte to the packet
            </summary>
            <param name="b"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.WriteTag(Goedel.Protocol.Presentation.PacketTag,System.Int64)">
            <summary>
            Write out a Tag-Length value using the shortest possible production.
            </summary>
            <param name="tag">Base code.</param>
            <param name="data">Length of data to follow.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.WriteStreamId(System.Byte[])">
            <summary>
            Write out the destination stream Id.
            </summary>
            <param name="data"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Int32)">
             <summary>
            Write the positive integer <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte[])">
            <summary>
            Write the binary data <paramref name="data"/> to the packet.
            </summary>
            <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Span{System.Byte})">
            <summary>
            Write the binary data contained in <paramref name="span"/> to the packet.
            </summary>
            <param name="span">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>
             Write the binary data  <paramref name="data"/> to the packet beginning
             at position <paramref name="offset"/> for <paramref name="count"/> bytes.
            </summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Write(System.String)">
             <summary>
            Write the string <paramref name="data"/> to the packet
             </summary>
             <param name="data">The data to write</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.WriteExtensions(System.Collections.Generic.List{Goedel.Protocol.Presentation.PacketExtension})">
            <summary>
            Write the list of extensions <paramref name="extensions"/> to the packet.
            </summary>
            <param name="extensions">The extensions to write.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.SkipBinary(System.Int32)">
            <summary>
            Skip forward to reserve space for a data item of <paramref name="length"/>
            bytes.
            </summary>
            <param name="length">Length of the data item to reserve space for.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Encrypt(System.Byte[],Goedel.Protocol.Presentation.PacketWriter,System.Boolean)">
            <summary>
            Fill out the remainder of the packet by using the value <paramref name="ikm"/>
            and a generated nonce to encrypt the data specified in <paramref name="packet"/>
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="packet">The plaintext data</param>
            <param name="pad">If true, fill the entire remainder of the packet.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriter.Wrap(System.Byte[],System.Byte[])">
            <summary>
            Wrap a data packet payload to create an encrypted data packet.
            </summary>
            <param name="ikm">The primary key.</param>
            <param name="streamId">The stream identifier.</param>
            <returns>The wrapped data packet.</returns>
        </member>
        <member name="T:Goedel.Protocol.Presentation.PacketWriterAesGcm">
            <summary>
            Encrypting packet writer.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.PacketWriterAesGcm.RemainingSpace">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.#ctor(System.Int32,System.Byte[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.Encrypt(System.Byte[],Goedel.Protocol.Presentation.PacketWriter,System.Boolean)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.PacketWriterAesGcm.Wrap(System.Byte[],System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ClientInitial">
            <summary>Inbound spool message state</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientInitial.Unknown">
            <summary>Undefined type</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientInitial.ClientInitialHello">
            <summary>Initial contact message without key exchange</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientInitial.ClientInitialExchange">
            <summary>Initial contact message with key exchange</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ClientInitial.PacketError">
            <summary>Error response</summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.HostMessageTags">
            <summary>Host response messages</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.HostMessageTags.Unknown">
            <summary>Undefined type</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.HostMessageTags.TagHostExchange">
            <summary>Host exchange message</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.HostMessageTags.TagHostChallenge1">
            <summary>Host challenge type 1</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.HostMessageTags.TagHostChallenge2">
            <summary>Host challenge type 2</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.HostMessageTags.TagHostComplete">
            <summary>Host exchange completetion</summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ErrorCodes">
            <summary>Response error codes</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.Unknown">
            <summary>Undefined type</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.BadRequest">
            <summary>Bad request</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.Unauthorized">
            <summary>Unauthorized</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.Forbidden">
            <summary>Forbidden</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.Timeout">
            <summary>Message timeout</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.TooManyRequests">
            <summary>Too many requests</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ErrorCodes.ServiceUnavailable">
            <summary>The service is unavailable</summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.ExtensionTags">
            <summary>Presentation extension tags</summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.ExtensionTags.Unknown">
            <summary>Undefined type</summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.RdpConnection">
            <summary>
            This class contains some material that should move to Goedel.Protocol.Presentation
            and some that should go to Goedel.Mesh. 
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.RdpListener">
            <summary>
            RDP Listener class, accepts connections from multiple sources and passes them to
            the specified service.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpListener.#ctor(Goedel.Protocol.Presentation.Credential)">
            <summary>
            Base constructor, populate the common properties.
            </summary>
            <param name="credential">The credential used by the listener.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpListener.GetTemporaryResponder(Goedel.Protocol.Presentation.Packet)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpListener.MakeChallenge(Goedel.Protocol.Presentation.Packet,System.Byte[])">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpListener.VerifyChallenge(Goedel.Protocol.Presentation.Packet)">
            <inheritdoc/>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpListener.Accept(Goedel.Protocol.Presentation.Packet)">
            <inheritdoc/>
        </member>
        <member name="T:Goedel.Protocol.Presentation.RdpStream">
            <summary>
            An RDP Stream
            </summary>
        </member>
        <member name="P:Goedel.Protocol.Presentation.RdpStream.RdpConnection">
            <summary>The underlying connection</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.RdpStream.ChildStreams">
            <summary>The child streams formed from this stream that MAY be rekeyed under this.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.RdpStream.LocalStreamId">
            <summary>The local stream Id, this is generated localy and MAY contain hidden structure.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.#ctor(Goedel.Protocol.Presentation.RdpStream,System.String,Goedel.Protocol.Presentation.Credential,Goedel.Protocol.Presentation.RdpConnection)">
            <summary>
            Initialize a new stream instance as a child of <paramref name="parent"/> to support
            protocol <paramref name="protocol"/> according to the stream role.
            </summary>
            <param name="parent">The parent stream</param>
            <param name="protocol">The stream protocol</param>
            <param name="credential">Optional additional credential.</param>
            <param name="rdpConnection">The parent connection (if specified, overrides <paramref name="parent"/></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.ForwardSecrecy(System.Boolean)">
            <summary>
            Perform a forward secrecy operation on the stream. If <paramref name="recurse"/> is
            true, the child streams will be marked to perform a rekey operation.
            </summary>
            <param name="recurse"></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.MakeStreamClient(Goedel.Protocol.Presentation.Credential)">
            <summary>
            Request creation of a transactional stream in the client role.
            </summary>
            <param name="credential">Optional additional credential to be presented.</param>
            <returns>The created stream.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.MakeStreamSender(Goedel.Protocol.Presentation.Credential)">
            <summary>
            Request creation of an asynchronous stream in the sender role.
            </summary>
            <param name="credential">Optional additional credential to be presented.</param>
            <returns>The created stream.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.MakeStreamService(Goedel.Protocol.Presentation.TransactionPostDelegate)">
            <summary>
            Request creation of a transactional stream in the server role
            </summary>
            <param name="transactionPostDelegate">Optional delegate to be called when a request is received.</param>
            <returns>The created stream.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.MakeStreamReceiver(Goedel.Protocol.Presentation.AsynchronousReceiveDelegate)">
            <summary>
            Request creation of an asynchronous stream in the receiver role.
            </summary>
            <param name="asynchronousReceiveDelegate">Optional delegate to be called when data is received.</param>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStream.Flush">
            <summary>
            Cause queued requests to be flushed.
            </summary>
        </member>
        <member name="T:Goedel.Protocol.Presentation.RdpStreamClient">
            <summary>
            The client side of an RDP transactional stream.
            </summary>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStreamClient.#ctor(Goedel.Protocol.Presentation.RdpStream,System.String,Goedel.Protocol.Presentation.Credential,Goedel.Protocol.Presentation.RdpConnection)">
            <summary>
            Initialize a new stream instance as a child of <paramref name="parent"/> to support
            protocol <paramref name="protocol"/> 
            </summary>
            <param name="parent">The parent stream</param>
            <param name="protocol">The stream protocol</param>
            <param name="credential">Optional additional credential.</param>
            <param name="rdpConnection">The parent connection (if specified, overrides <paramref name="parent"/></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStreamService.#ctor(Goedel.Protocol.Presentation.RdpStream,System.String,Goedel.Protocol.Presentation.Credential,Goedel.Protocol.Presentation.RdpConnection)">
            <summary>
            Initialize a new stream instance as a child of <paramref name="parent"/> to support
            protocol <paramref name="protocol"/> 
            </summary>
            <param name="parent">The parent stream</param>
            <param name="protocol">The stream protocol</param>
            <param name="credential">Optional additional credential.</param>
            <param name="rdpConnection">The parent connection (if specified, overrides <paramref name="parent"/></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStreamSender.#ctor(Goedel.Protocol.Presentation.RdpStream,System.String,Goedel.Protocol.Presentation.Credential,Goedel.Protocol.Presentation.RdpConnection)">
            <summary>
            Initialize a new stream instance as a child of <paramref name="parent"/> to support
            protocol <paramref name="protocol"/> 
            </summary>
            <param name="parent">The parent stream</param>
            <param name="protocol">The stream protocol</param>
            <param name="credential">Optional additional credential.</param>
            <param name="rdpConnection">The parent connection (if specified, overrides <paramref name="parent"/></param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.RdpStreamReceiver.#ctor(Goedel.Protocol.Presentation.RdpStream,System.String,Goedel.Protocol.Presentation.Credential,Goedel.Protocol.Presentation.RdpConnection)">
            <summary>
            Initialize a new stream instance as a child of <paramref name="parent"/> to support
            protocol <paramref name="protocol"/> 
            </summary>
            <param name="parent">The parent stream</param>
            <param name="protocol">The stream protocol</param>
            <param name="credential">Optional additional credential.</param>
            <param name="rdpConnection">The parent connection (if specified, overrides <paramref name="parent"/></param>
        </member>
        <member name="T:Goedel.Protocol.Presentation.StreamId">
            <summary>
            Structure managing stream ids
            </summary>
        </member>
        <member name="F:Goedel.Protocol.Presentation.StreamId.Counter">
            <summary>Counter used to allocate unique IDs</summary> 
        </member>
        <member name="F:Goedel.Protocol.Presentation.StreamId.SourceIdSize">
            <summary>Size of fixed length Ids generated by this struct.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.StreamId.Value">
            <summary>The stream Id value as an unsigned 64 bit integer.</summary> 
        </member>
        <member name="P:Goedel.Protocol.Presentation.StreamId.PacketExtension">
            <summary>Factory method, creates a packet extension wrapping the stream identifier.</summary> 
        </member>
        <member name="M:Goedel.Protocol.Presentation.StreamId.#ctor(System.UInt64)">
            <summary>
            Create an instance with the stream Id value <paramref name="value"/>.
            </summary>
            <param name="value">The stream identifier value.</param>
        </member>
        <member name="M:Goedel.Protocol.Presentation.StreamId.GetClientCompleteDeferred">
            <summary>
            Return a new stream identifier that is identifiable as being for a packet of type 
            <see cref="F:Goedel.Protocol.Presentation.StreamId.ClientCompleteDeferred"/>
            </summary>
            <returns>The stream identifier.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.StreamId.GetValue">
            <summary>
            Return the stream identifier value as a byte sequence.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.StreamId.GetSourceId(System.Byte[])">
            <summary>
            Process the initial bytes of the buffer to get the source ID value according to the 
            source ID processing mode specified for the session.
            </summary>
            <param name="buffer"></param>
            <returns>The retrieved sourceId and position in the buffer.</returns>
        </member>
        <member name="M:Goedel.Protocol.Presentation.StreamId.GetStreamId">
            <summary>
            Factory method returing a new unique stream identifier.
            </summary>
            <returns>The stream identifier created.</returns>
        </member>
        <member name="T:Goedel.Protocol.PacketSizeExceeded">
            <summary>
            The packet was too small to contain the data
            </summary>
        </member>
        <member name="P:Goedel.Protocol.PacketSizeExceeded.ExceptionFormatDelegate">
            <summary>The exception formatting delegate. May be overriden 
            locally or globally to implement different exception formatting.</summary>
        </member>
        <member name="F:Goedel.Protocol.PacketSizeExceeded.Templates">
            <summary>Templates for formatting response messages.</summary>
        </member>
        <member name="M:Goedel.Protocol.PacketSizeExceeded.#ctor(System.String,System.Exception,System.Object[])">
            <summary>
            Construct instance for exception
            </summary>		
            <param name="description">Description of the error, may be used to override the 
            generated message.</param>	
            <param name="inner">Inner Exception</param>	
            <param name="args">Optional list of parameterized arguments.</param>
        </member>
        <member name="M:Goedel.Protocol.PacketSizeExceeded._Throw(System.Object)">
            <summary>
            The public fatory delegate
            </summary>
            public static global::Goedel.Utilities.ThrowNewDelegate ThrowNew = _Throw;
        </member>
        <member name="F:Goedel.Protocol.PacketSizeExceeded.Throw">
            <summary>
            The public fatory delegate
            </summary>
        </member>
        <member name="T:Goedel.Protocol.InvalidClientState">
            <summary>
            The client is in an invalid state for the requested operation.
            </summary>
        </member>
        <member name="P:Goedel.Protocol.InvalidClientState.ExceptionFormatDelegate">
            <summary>The exception formatting delegate. May be overriden 
            locally or globally to implement different exception formatting.</summary>
        </member>
        <member name="F:Goedel.Protocol.InvalidClientState.Templates">
            <summary>Templates for formatting response messages.</summary>
        </member>
        <member name="M:Goedel.Protocol.InvalidClientState.#ctor(System.String,System.Exception,System.Object[])">
            <summary>
            Construct instance for exception
            </summary>		
            <param name="description">Description of the error, may be used to override the 
            generated message.</param>	
            <param name="inner">Inner Exception</param>	
            <param name="args">Optional list of parameterized arguments.</param>
        </member>
        <member name="M:Goedel.Protocol.InvalidClientState._Throw(System.Object)">
            <summary>
            The public fatory delegate
            </summary>
            public static global::Goedel.Utilities.ThrowNewDelegate ThrowNew = _Throw;
        </member>
        <member name="F:Goedel.Protocol.InvalidClientState.Throw">
            <summary>
            The public fatory delegate
            </summary>
        </member>
    </members>
</doc>

using  System.Text;
using  Goedel.Mesh;
using  Goedel.Mesh.Shell;
using  Goedel.Protocol;
 #pragma warning disable IDE0022
 #pragma warning disable IDE0060
 #pragma warning disable IDE1006
using System;
using System.IO;
using System.Collections.Generic;
using Goedel.Registry;
namespace ExampleGenerator;
public partial class CreateExamples : global::Goedel.Registry.Script {

	

	//
	// WebDare
	//
	public static void WebDare(CreateExamples Examples) { /* XFile  */
			using var _Output = new StreamWriter("Guide/dare.md");
		Examples._Output = _Output;
		Examples._WebDare(Examples);
		}
	public void _WebDare(CreateExamples Examples) {

			 MakeTitle ("dare");
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare` command set contains commands that encode, decode and verify \n{0}", _Indent);
			_Output.Write ("DARE envelopes and sequences.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Encoding a file as a DARE message.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command is used to encode files as DARE Messages:\n{0}", _Indent, ToCommand("dare encode"));
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DarePlaintext);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("In this case, the file `{1}` contains the text `\"{2}\"`.\n{0}", _Indent, TestFile1, TestText1);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("By default, a content digest is calculated over the contents. This may be \n{0}", _Indent);
			_Output.Write ("suppressed using the `/nohash` flag.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The data contents may be encrypted and authenticated under a specified symmetric key:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareSymmetric);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Specifying a directory instead of a file causes all the files in the directory to be \n{0}", _Indent);
			_Output.Write ("encoded:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareSub);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Files may also be signed using the user's Mesh signature key and/or encrypted for one\n{0}", _Indent);
			_Output.Write ("or more recipients. In this example, Alice creates a message intended for Bob.\n{0}", _Indent);
			_Output.Write ("Alice signs the message with her private signature key and encrypts it under Bob's\n{0}", _Indent);
			_Output.Write ("public encryption key.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareMesh);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Verifying a DARE message.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command is used to verify the signature and \n{0}", _Indent, ToCommand("dare verify"));
			_Output.Write ("digest values on a DARE Message without decoding the message body:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareVerifyDigest);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The command to verify a signed message is identical:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareVerifySigned);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Messages that are encrypted and authenticated under a specified symmetric key \n{0}", _Indent);
			_Output.Write ("may be verified at the plaintext level if the key is known or the ciphertext \n{0}", _Indent);
			_Output.Write ("level otherwise.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareVerifySymmetric);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareVerifySymmetricUnknown);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Decoding a DARE message to a file.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command is used to decode and verify DARE Messages:\n{0}", _Indent, ToCommand("dare decode"));
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareDecodePlaintext);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("To decode a message encrypted under a symmetric key, we must specify the key:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareDecodeSymmetric);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("If the message is encrypted under our private encryption key, the tool will locate\n{0}", _Indent);
			_Output.Write ("the necessary decryption key(s) automatically:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareDecodePrivate);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Creating an EARL.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command is used to create an EARL:\n{0}", _Indent, ToCommand("dare earl"));
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareEarl);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("A new secret is generated with the specified number of bits, this is then used\n{0}", _Indent);
			_Output.Write ("to generate the key identifier and encrypt the input file to a file with the\n{0}", _Indent);
			_Output.Write ("name of the key identifier.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `/log` option causes the filename, encryption key and other details of\n{0}", _Indent);
			_Output.Write ("the transaction to be written to a DARE Container Log.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareEARLLog);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `/new` option causes the file to be encoded if and only if it has not \n{0}", _Indent);
			_Output.Write ("been processed already.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellDare.DareEARLLogNew);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Creating Sequences\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Containers are created with either the {1} or \n{0}", _Indent, ToCommand("dare archive"));
			_Output.Write ("{1}. Both commands create a sequence with the \n{0}", _Indent, ToCommand("dare log"));
			_Output.Write ("specified cryptographic enhancements. The {1}\n{0}", _Indent, ToCommand("container archive"));
			_Output.Write ("command additionally adds the specified file(s) to the container to create \n{0}", _Indent);
			_Output.Write ("a container archive.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerCreate);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("*catalog* *spool* *archive* *log*\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The cryptographic enhancements specified when a container is created have the \n{0}", _Indent);
			_Output.Write ("same format and function as for DARE Messages but their scope is the container\n{0}", _Indent);
			_Output.Write ("as a whole.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("For example, Alice creates an encrypted container readable by anyone who is a\n{0}", _Indent);
			_Output.Write ("member of the group {1};\n{0}", _Indent, GroupAccount);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerCreateEncrypt);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Since it is rarely desirable to sign every entry in a container, signatures\n{0}", _Indent);
			_Output.Write ("are typically added to a container when entries or indexes are added. \n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} creates a new container, adds the\n{0}", _Indent, ToCommand("container archive"));
			_Output.Write ("specified file(s) as entries and appends an index as the final record:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchive);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("An archive may be signed and encrypted:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveEnhance);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The signature on a signed archive is calculated over the final apex of the \n{0}", _Indent);
			_Output.Write ("Merkel tree. Thus a single signature verification may be used to validate\n{0}", _Indent);
			_Output.Write ("any or all entries in the container.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Reading Containers\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command verifies the contents of a container: \n{0}", _Indent, ToCommand("dare verify"));
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveVerify);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The verification performed depends on the type of authentication applied to the\n{0}", _Indent);
			_Output.Write ("container and whether the verifier can provide the necessary authentication or\n{0}", _Indent);
			_Output.Write ("decryption keys.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} \n{0}", _Indent, ToCommand("dare extract"));
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("One or more container entries may be extracted to a file using the  \n{0}", _Indent);
			_Output.Write ("{1} command. If the container is an archive, all\n{0}", _Indent, ToCommand("container extract"));
			_Output.Write ("the files are extracted by default:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveExtractAll);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Alternatively, the `/file` option may be used to extract a specific file:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveExtractFile);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Writing to Archives \n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command adds an entry to a container:\n{0}", _Indent, ToCommand("dare append"));
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerAppend);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("If no security enhancements are specified, the default enhancements specified \n{0}", _Indent);
			_Output.Write ("in the index entry are applied.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} \n{0}", _Indent, ToCommand("dare delete"));
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command adds an entry to a container\n{0}", _Indent, ToCommand("container delete"));
			_Output.Write ("marking an entry as deleted:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerDelete);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Marking an entry for deletion does not cause the entry itself to be modified.\n{0}", _Indent);
			_Output.Write ("The entry is merely marked as having been deleted. To erase the entry contents,\n{0}", _Indent);
			_Output.Write ("it is necessary to either make a copy of the container using the `/purge`\n{0}", _Indent);
			_Output.Write ("option to reclaim the space used by deleted entries or to use the \n{0}", _Indent);
			_Output.Write ("`/erase` or `overwrite` options.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command adds an index entry to the end of\n{0}", _Indent, ToCommand("dare index"));
			_Output.Write ("container:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerIndex);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The index entry may be complete, providing an index of the entire file \n{0}", _Indent);
			_Output.Write ("or incremental, only indexing the items added since the last index was created.\n{0}", _Indent);
			_Output.Write ("Indexing containers allows the contents to be efficiently retrieved.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Writing to Logs\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("## Purging Sequences\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command makes a copy of a container with\n{0}", _Indent, ToCommand("dare purge"));
			_Output.Write ("the specified filtering rules. By default, no changes are made except to \n{0}", _Indent);
			_Output.Write ("collect tree index fields dispersed throughout the container with an index \n{0}", _Indent);
			_Output.Write ("at the end:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveCopy);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The copy command may be used to encrypt or decrypt the container contents during \n{0}", _Indent);
			_Output.Write ("the copy:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveCopyDecrypt);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The copy command may also be used to reclaim space used by deleted items:\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleExample (ShellSequence.ContainerArchiveCopyPurge);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
				}
	

	//
	// DareReference
	//
	public static void DareReference(CreateExamples Examples) { /* XFile  */
			using var _Output = new StreamWriter("Reference/dare.md");
		Examples._Output = _Output;
		Examples._DareReference(Examples);
		}
	public void _DareReference(CreateExamples Examples) {

			 var CommandSet = CommandLineInterpreter.DescribeCommandSet_Dare;
			 Describe(CommandSet);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare` command set contains commands that encode, decode and verify \n{0}", _Indent);
			_Output.Write ("DARE envelopes and sequences.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerArchiveExtractAll);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareAppend._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare append` command appends the specified file to the container.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerAppend);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareArchive._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare archive` command creates an archive with the specified cryptographic\n{0}", _Indent);
			_Output.Write ("enhancements.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerArchive);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareDecode._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare decode` command decodes the specified input file using keys found in the\n{0}", _Indent);
			_Output.Write ("currently active key collection.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The active key collection may be overriden using the `/mesh` option.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `/out` option may be used to specify the output file name. Otherwise the output\n{0}", _Indent);
			_Output.Write ("file name is the input file name stripped of the extension `.dare` if present or\n{0}", _Indent);
			_Output.Write ("with the extension `.undare` otherwise.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellDare.DareDecodeSymmetric);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareDelete._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare delete` command marks the specified file entry as deleted in the\n{0}", _Indent);
			_Output.Write ("container but does not erase the data from the file.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerDelete);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareDir._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare dir` command returns a directory listing for the specified archive.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareEARL._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The {1} command is used to encode an input file and return\n{0}", _Indent, ToCommand("dare earl"));
			_Output.Write ("(or log) the corresponding identifier information in a format that enables use\n{0}", _Indent);
			_Output.Write ("as an Encrypted Authenticated Resource Locator.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("If the input file specified is a file, the tool processes that file. If the\n{0}", _Indent);
			_Output.Write ("input file is a directory, the tool processes all the files in the directory. If the\n{0}", _Indent);
			_Output.Write ("`/sub` option is specified, subdirectories are processed recursively.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("If the `/log` or `/new` option is specified, the filename, encryption key and other details of\n{0}", _Indent);
			_Output.Write ("each completed transaction are written to a DARE Container Log. If `/log` is specified, the \n{0}", _Indent);
			_Output.Write ("file is always processed. If `/new` is specified, files are only\n{0}", _Indent);
			_Output.Write ("processed if there is no existing entry in the specified log.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The log file must be initialized before use (eg. using the {1} \n{0}", _Indent, ToCommand("container create"));
			_Output.Write ("command). Log entries are written with the cryptographic enhancements specified in\n{0}", _Indent);
			_Output.Write ("the container using the active key collection.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The active key collection may be overriden using the `/mesh` option.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellDare.DareEarl);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareEncode._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare encode` command encrypts a file and writes the output to a DARE Message.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("If the input file specified is a file, the tool processes that file. If the\n{0}", _Indent);
			_Output.Write ("input file is a directory, the tool processes all the files in the directory. If the\n{0}", _Indent);
			_Output.Write ("`/sub` option is specified, subdirectories are processed recursively.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("By default, a digest value is calculated over the message body (i.e. the ciphertext\n{0}", _Indent);
			_Output.Write ("if it is encrypted). This may be suppressed using the `/nohash` option.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The tool attempts to determine the IANA media type of the file from the file \n{0}", _Indent);
			_Output.Write ("extension. This may be overriden using the /cty `option`.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Encryption and Signature enhancements may be specified with the `/sign` and \n{0}", _Indent);
			_Output.Write ("`/encrypt` options. \n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("* Key parameters that have the form of a UDF secret (Exxx-xxxx-...) are interpreted\n{0}", _Indent);
			_Output.Write ("as symmetric encryption keys and used to encrypt the contents directly.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("* Key parameters that have the form of an Internet user account (\\<user\\>@\\<domain\\> are \n{0}", _Indent);
			_Output.Write ("resolved according to the currently active key collection.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The active key collection may be overriden using the `/mesh` option.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("Algorithms for public key operations are inferred from the keys provided. The \n{0}", _Indent);
			_Output.Write ("`\\alg` option may be used to override the inferred or default algorithms.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `/out` option may be used to specify the output file name. Otherwise the output\n{0}", _Indent);
			_Output.Write ("file name is the input file name with the additional extension `.dare`.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellDare.DareSymmetric);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareExtract._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare extract` command extracts the specified container entries and writes them\n{0}", _Indent);
			_Output.Write ("to files.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareIndex._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare index` command appends an index record to the end of the container.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerIndex);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareList._DescribeCommand);
			 Describe(CommandSet, _DareLog._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare log` command creates a sequence with the specified cryptographic\n{0}", _Indent);
			_Output.Write ("enhancements.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerCreate);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DarePurge._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare purge` command copies a container applying the specified filtering \n{0}", _Indent);
			_Output.Write ("and indexing criteria.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellSequence.ContainerArchiveCopy);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareSequence._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			 Describe(CommandSet, _DareVerify._DescribeCommand);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The `dare decode` command verifies the specified input file using keys found in the\n{0}", _Indent);
			_Output.Write ("currently active key collection and reports success or failure.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("The active key collection may be overriden using the `/mesh` option.\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			 ConsoleReference (ShellDare.DareVerifySymmetric);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
			_Output.Write ("\n{0}", _Indent);
				}
		}

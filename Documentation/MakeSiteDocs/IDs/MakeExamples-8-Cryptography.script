#using System.Text
#using Goedel.Mesh
#using Goedel.Protocol
#using Goedel.Utilities
#% #pragma warning disable IDE0022
#% #pragma warning disable IDE0060
#% #pragma warning disable IDE1006
#xclass ExampleGenerator CreateExamples

#method MakeCryptographyExamples CreateExamples Example
#% ExamplesThreshold(Example);
#!% ExamplesAdvancedCoGeneration(Example);
#!% ExamplesAdvancedRecryption(Example);
#!% ExamplesAdvancedQuantum(Example);
#end method


#xfile CreateExamples ExamplesThreshold "Examples\\ExamplesThreshold.md" CreateExamples Example
#% var threshold = Example.Threshold;

#### Threshold Key Generation

###### X25519

#call DescribeKeyGen threshold.KeyGenX25519


###### X448

#%call DescribeKeyGen threshold.KeyGenX448

###### Ed25519

#%call DescribeKeyGen threshold.KeyGenEd25519

###### Ed448

#%call DescribeKeyGen threshold.KeyGenEd448

#### Threshold Decryption

###### Key Splitting X25519

#call DescribeDecryptSplitting threshold.DecryptX25519

###### Decryption X25519

#call DescribeDecryptUse threshold.DecryptX25519

###### Key Splitting X448

#%call DescribeDecryptSplitting threshold.DecryptX448

###### Decryption X448

#%call DescribeDecryptUse threshold.DecryptX448

#end xfile


#method DescribeDecryptUse Decrypt Decrypt

The means of encryption is unchanged. We begin by generating an ephemeral 
key pair:

~~~~
#call DescribeKey Decrypt.KeyE
~~~~

The key agreement result is given by multiplying the public key of the encryption 
pair by the secret scalar of the ephemeral key to obtain the u-coordinate of the result.

~~~~
#{Decrypt.KeyEA.XTag}: {Key.X}
~~~~

The u-coordinate is encoded in the usual fashion (i.e. without specifying the sign of v).

~~~~
#{Decrypt.KeyEA.Public.ToStringBase16FormatHex()}
~~~~

The first decryption contribution is generated from the secret scalar of the first key
share and the public key of the ephemeral.

The outputs from the Montgomery Ladder are:

~~~~
x_2 #{Decrypt.KeyE1.X2}
z_2 #{Decrypt.KeyE1.Z2}
x_3 #{Decrypt.KeyE1.X3}
z_3 #{Decrypt.KeyE1.Z3}
~~~~

The coordinates of the corresponding point are:

~~~~
u #{Decrypt.KeyE1.X}
v #{Decrypt.KeyE1.Y}
~~~~

The encoding of this point specifies the u coordinate and the sign (oddness) of the 
v coordinate:

~~~~
#{Decrypt.KeyE1.Public.ToStringBase16FormatHex()}
~~~~

The second decryption contribution is generated from the secret scalar of the second key
share and the public key of the ephemeral in the same way:

~~~~
u #{Decrypt.KeyE2.X}
v #{Decrypt.KeyE2.Y}
~~~~

~~~~
#{Decrypt.KeyE2.Public.ToStringBase16FormatHex()}
~~~~

To obtain the key agreement value, we add the two decryption contributions:

~~~~
u #{Decrypt.KeyE12.X}
v #{Decrypt.KeyE12.Y}
~~~~

This returns the same u coordinate value as before, allowing us to obtain the encoding 
of the key agreement value and decrypt the message.


#end method

#method DescribeDecryptSplitting Decrypt Decrypt

The encryption key pair is

~~~~
#call DescribeKey Decrypt.KeyA
~~~~

To create n key shares we first create n-1 key pairs in the normal fashion. Since 
these key pairs are only used for decryption operations, it is not necessary to 
calculate the public components:

~~~~
#call DescribeKeyPrivate Decrypt.Key1
~~~~

The secret scalar of the final key share is the secret scalar of the base key minus
the sum of the secret scalars of the other shares modulo the group order:

~~~~
Scalar_2 = (Scalar_A - Scalar_1) mod L
    = #{Decrypt.Key1.Scalar}
This is encoded as a binary integer in little endian format:
#{Decrypt.Key2.Private.ToStringBase16FormatHex()}
~~~~


#end method

#method DescribeKeyGen KeyGen KeyGen
The key parameters of the first key contribution are:

~~~~
#call DescribeKey KeyGen.Key1
~~~~

The key parameters of the second key contribution are:

~~~~
#call DescribeKey KeyGen.Key2
~~~~

The aggregate private key is:

~~~~
Scalar_A = (Scalar_1 + Scalar_2) mod L
  = #{KeyGen.KeyA.Scalar}

Encoded Aggrgate Private Key:
#{KeyGen.KeyA.Private.ToStringBase16FormatHex()}
~~~~

The aggregate public key is:

~~~~
Point_A = Point_1 + Point_2

#{KeyGen.KeyA.XTag}: #{KeyGen.KeyA.X}
#{KeyGen.KeyA.YTag}: #{KeyGen.KeyA.Y}

Encoded Public#{KeyGen.KeyA.Public.ToStringBase16FormatHex()}
~~~~

#end method



#method DescribeKeyPrivate CurveKey Key
#{Key.Name} (#{Key.Curve})
    UDF:        #{Key.UDF}
    Scalar:     #{Key.Scalar}
    Encoded Private#{Key.Private.ToStringBase16FormatHex()}
#end method

#method DescribeKey CurveKey Key
#call DescribeKeyPrivate Key
    #{Key.XTag}: #{Key.X}
    #{Key.YTag}: #{Key.Y}
    Encoded Public#{Key.Public.ToStringBase16FormatHex()}
#end method




#file ExamplesAdvancedCoGeneration "Examples\\ExamplesAdvancedCoGeneration.md" CreateExamples Example
####Example: Provisioning the Confirmation Service
#% var Section = Example.CryptoCombine;

For example, Alice provisions the confirmation service to her watch. The device profile
of the watch specifies an Ed25519 signature key. Note that for production use, Ed448 is
almost certainly prefered but Ed25519 has the advantage of more compact presentation.

~~~~
Device Key

UDF Seed:       #{Section.SeedAliceDevice}
Private Key:#{Section.KeyPairDevicePrivate.ToStringBase16FormatHex()}
Secret Scalar:
#{Section.SecretScalarDevice}
Public Key:#{Section.KeyPairDevice.PublicData.ToStringBase16FormatHex()}
Fingerprint:    #{Section.KeyPairDevice.UDF}
~~~~

The provisioning device could generate a signature key for the device and encrypt it
under the encryption key of the device. But this means that we cannot attribute signatures
to the watch with absolute certainty as the provisioning device has had knowledge of the 
watch signature key. Nor do we wish to use the device signature key for the confirmation
service.

Instead, the provisioning device generates an overlay keypair:

~~~~
Device Key

UDF Seed:       #{Section.SeedAliceOverlay}
Private Key:#{Section.KeyPairOverlayPrivate.ToStringBase16FormatHex()}
Secret Scalar:
#{Section.SecretScalarOverlay}
Public Key:#{Section.KeyPairOverlay.PublicData.ToStringBase16FormatHex()}
Fingerprint:    #{Section.KeyPairOverlay.UDF}
~~~~

The provisioning device can calculate the public key of the composite keypair
by adding the public keys of the device profile and the companion public key:

~~~~
Composite public key = Device + Overlay:#{Section.CombinedPublic.PublicData.ToStringBase16FormatHex()}
Fingerprint:    #{Section.CombinedPublic.UDF}
~~~~

The provisioning device encrypts the private key of the comanion keypair (or the seed from which it
was generated) under the encryption key of the device. 

The provisioning device calculates the private key of the composite keypair by 
adding the two private key values modulo the order of the group and verifies that scalar 
multiplication of the base point returns the composite public key value.

~~~~
Composite Secret Scalar = Device + Overlay:
#{Section.SecretScalarComposite}
Fingerprint:    #{Section.CombinedPrivate.UDF}
~~~~


#end file

#file ExamplesAdvancedRecryption "Examples\\ExamplesAdvancedRecryption.md" CreateExamples Example
#% var Section = Example.CryptoGroup;
####Example: Messaging group

NB: The current code implements encryption in the Elliptic Curve Ed25519, not the Montgomery
Curve X.25519 as it should. This will be lifted in the near future.

Alice creates an encryption keypair.

~~~~
Group Key:#{Section.KeyPairGroupPrivate.ToStringBase16FormatHex()}
Value:
#{Section.KeyPairGroupPrivateInt}
~~~~

To verify the proper function of the group, Alice creates a test message and 
encrypts it under the group key.

~~~~
Message = #{Section.PlaintextText} as UTF8:#{Section.Plaintext.ToStringBase16FormatHex()}

#{Section.Envelope}
~~~~

Alice decides to add Bob to the group. She creates an encryption key for Bob:
The decryption key is specified in the same way as any other Ed25519 private key
using the hash of a private key seed value:

~~~~
Bob's Member Key:#{Section.KeyPairDevicePrivate.ToStringBase16FormatHex()}
Value:
#{Section.KeyPairDevicePrivateInt}
~~~~

The the recryption key is the group secret scalar minus  (mod p) the secret scalar of Bob's
private key:

~~~~
Bob's Service Key:
   [Not specified as a digest input value]
Value:
#{Section.KeyPairServicePrivateInt}
~~~~

To decrypt:

~~~~
Member Agreement Value:#{Section.KeyPairDeviceWrapped.PartialDeviceEncoded.ToStringBase16FormatHex()}

Service Agreement Value:#{Section.KeyPairDeviceWrapped.PartialServiceEncoded.ToStringBase16FormatHex()}

Key Agreement IKM:#{Section.KeyPairDeviceWrapped.Result.ToStringBase16FormatHex()}
~~~~

This value allows the test message to be decrypted.


#end file

#file ExamplesAdvancedQuantum "Examples\\ExamplesAdvancedQuantum.md" CreateExamples Example
####Example: Creating a Quantum Resistant Signature Fingerprint

Alice decides to add a QRSF to her Mesh Profile. She creates
a 256 bit master secret.

~~~~
TBS: #{Example.AdvancedQuantumMasterSecret}
~~~~

To enable recovery of the master key, Alice creates five keyshares with a quorum of three:

~~~~
TBS: #{Example.AdvancedQuantumShares}
~~~~

Alice uses the master secret to derrive her private key values:

~~~~
TBS: #{Example.AdvancedQuantumPrivate}
~~~~

These values are used to generate the public key value:

~~~~
TBS: #{Example.AdvancedQuantumPublic}
~~~~

The QRSF contains the UDF fingerprint of the public key
value plus the XMSS parameters:

~~~~
TBS: #{Example.AdvancedQuantumPublicUDF}
~~~~

Alice adds the QRSF to her profile and publishes it to a Mesh Service that is enrolled
in at least one multi-party notary scheme.


#end file

#file Blahhh "Examples\\Blahhh.md" CreateExamples Example
The Recryption entry consists of Bob's address, the recryption key and the decryption
key encrypted under Bob's encryption key:


~~~~
TBS: #{Example.AdvancedRecryptionBobRecryptionEntry}
~~~~

The group administration tool creates a notification request to tell Bob that
he has been made a member of the new group and signs it using the group signature
key. The recryption entry and the notification are then sent to the recryption
service:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionAddMemberRequest}
~~~~

The notification message contains a link to the test message. When he accepts
membership of the group, Bob clicks on the link to test that his membership
has been fully provisioned. Providing an explicit test mechanism avoids the problem
that might otherwise occur in which the message spool fills up with test messages 
being posted.

Bob's Web browser requests the recryption data for the test message. The request is 
authenticated and encrypted under Bob's device keys. The plaintext of the message is:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionRequest}
~~~~

The plaintext of the response contains the additional information Bob's Web browser
needs to complete the decryption process:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionResponse}
~~~~

The Web browser decrypts the private key and uses it to calculate the decryption 
value:

~~~~
TBS: #{Example.AdvancedRecryptionDecryptionValue}
~~~~

The key agreement value is obtained by point addition of the recryption and decryption
values:
#end file
#end xclass


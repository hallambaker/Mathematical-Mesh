#using System.Text
#using Goedel.Mesh
#using Goedel.Protocol
#using Goedel.Utilities
#% #pragma warning disable IDE0022
#% #pragma warning disable IDE0060
#% #pragma warning disable IDE1006
#xclass ExampleGenerator CreateExamples

#method MakeCryptographyExamples CreateExamples Example
#% ExamplesThreshold(Example);
#% ExamplesThresholdSig(Example);
#end method


#xfile CreateExamples ExamplesThreshold "Examples\\ExamplesThreshold.md" CreateExamples Example
#% var threshold = Example.Threshold;

#### Threshold Key Generation

###### X25519

#call DescribeKeyGen threshold.KeyGenX25519


###### X448

#call DescribeKeyGen threshold.KeyGenX448

###### Ed25519

#call DescribeKeyGen threshold.KeyGenEd25519

###### Ed448

#call DescribeKeyGen threshold.KeyGenEd448

#### Threshold Decryption

###### Key Splitting X25519

#call DescribeDecryptSplitting threshold.DecryptX25519

###### Decryption X25519

#call DescribeDecryptUse threshold.DecryptX25519

###### Key Splitting X448

#call DescribeDecryptSplitting threshold.DecryptX448

###### Decryption X448

#call DescribeDecryptUse threshold.DecryptX448

#end xfile


#method DescribeDecryptUse Decrypt Decrypt

The means of encryption is unchanged. We begin by generating an ephemeral 
key pair:

~~~~
#call DescribeKey Decrypt.KeyE
~~~~

The key agreement result is given by multiplying the public key of the encryption 
pair by the secret scalar of the ephemeral key to obtain the u-coordinate of the result.

~~~~
#{Decrypt.KeyEA.XTag}: #{Decrypt.KeyEA.X}
~~~~

The u-coordinate is encoded in the usual fashion (i.e. without specifying the sign of v).

~~~~
#{Decrypt.KeyEA.Public.ToStringBase16FormatHex()}
~~~~

The first decryption contribution is generated from the secret scalar of the first key
share and the public key of the ephemeral.

The outputs from the Montgomery Ladder are:

~~~~
x_2 #{Decrypt.KeyE1.X2}
z_2 #{Decrypt.KeyE1.Z2}
x_3 #{Decrypt.KeyE1.X3}
z_3 #{Decrypt.KeyE1.Z3}
~~~~

The coordinates of the corresponding point are:

~~~~
u #{Decrypt.KeyE1.X}
v #{Decrypt.KeyE1.Y}
~~~~

The encoding of this point specifies the u coordinate and the sign (oddness) of the 
v coordinate:

~~~~
#{Decrypt.KeyE1.Public.ToStringBase16FormatHex()}
~~~~

The second decryption contribution is generated from the secret scalar of the second key
share and the public key of the ephemeral in the same way:

~~~~
u #{Decrypt.KeyE2.X}
v #{Decrypt.KeyE2.Y}
~~~~

~~~~
#{Decrypt.KeyE2.Public.ToStringBase16FormatHex()}
~~~~

To obtain the key agreement value, we add the two decryption contributions:

~~~~
u #{Decrypt.KeyE12.X}
v #{Decrypt.KeyE12.Y}
~~~~

This returns the same u coordinate value as before, allowing us to obtain the encoding 
of the key agreement value and decrypt the message.


#end method

#method DescribeDecryptSplitting Decrypt Decrypt

The encryption key pair is

~~~~
#call DescribeKey Decrypt.KeyA
~~~~

To create n key shares we first create n-1 key pairs in the normal fashion. Since 
these key pairs are only used for decryption operations, it is not necessary to 
calculate the public components:

~~~~
#call DescribeKeyPrivate Decrypt.Key1
~~~~

The secret scalar of the final key share is the secret scalar of the base key minus
the sum of the secret scalars of the other shares modulo the group order:

~~~~
Scalar_2 = (Scalar_A - Scalar_1) mod L
    = #{Decrypt.Key2.Scalar}
This is encoded as a binary integer in little endian format:
#{Decrypt.Key2.Private.ToStringBase16FormatHex()}
~~~~


#end method

#method DescribeKeyGen KeyGen KeyGen
The key parameters of the first key contribution are:

~~~~
#call DescribeKey KeyGen.Key1
~~~~

The key parameters of the second key contribution are:

~~~~
#call DescribeKey KeyGen.Key2
~~~~

The aggregate private key is:

~~~~
Scalar_A = (Scalar_1 + Scalar_2) mod L
  = #{KeyGen.KeyA.Scalar}

Encoded Aggrgate Private Key:
#{KeyGen.KeyA.Private.ToStringBase16FormatHex()}
~~~~

The aggregate public key is:

~~~~
Point_A = Point_1 + Point_2

#{KeyGen.KeyA.XTag}: #{KeyGen.KeyA.X}
#{KeyGen.KeyA.YTag}: #{KeyGen.KeyA.Y}

Encoded Public#{KeyGen.KeyA.Public.ToStringBase16FormatHex()}
~~~~

#if (KeyGen.KeyA.IsCurveX) 
Note that in this case, the unsigned representation of the key is used as
the aggregate key is intended for unsigned CurveX key agreement. If the
result is intended for use as a key contribution, the signed representation
is required.

#end if
#end method



#method DescribeKeyPrivate CurveKey Key
#{Key.Name} (#{Key.Curve})
    UDF:        #{Key.UDF}
    Scalar:     #{Key.Scalar}
    Encoded Private#{Key.Private.ToStringBase16FormatHex()}
#end method

#method DescribeKey CurveKey Key
#call DescribeKeyPrivate Key
    #{Key.XTag}: #{Key.X}
    #{Key.YTag}: #{Key.Y}
    Encoded Public#{Key.Public.ToStringBase16FormatHex()}
#end method

#xfile CreateExamples ExamplesThresholdSig "Examples\\ExamplesThresholdSig.md" CreateExamples Example
#### Unanimous Threshold Signature Ed25519

#call Describe Example.ThresholdSignature.UnanimousEd25519

#### Unanimous Threshold Signature Ed448

#call Describe Example.ThresholdSignature.UnanimousEd448

#### Quorate Threshold Signature Ed25519

#call Describe Example.ThresholdSignature.QuorateEd25519

#### Quorate Threshold Signature Ed448

#call Describe Example.ThresholdSignature.QuorateEd448

#end xfile

#method Describe Quorate sig

The administrator creates the aggregate key pair

~~~~
#call DescribeKey sig.KeyAggregate
~~~~

Three key shares are required for Alice, Bob and Carol with a threshold of two. 
The parameters of the Shamir Secret Sharing polynomial are:

~~~~
a0 = #{sig.A0}
a1 = #{sig.A1}
a2 = #{sig.A2}
~~~~

The key share values for the participants are

~~~~
xa = #{sig.Xa}
fa = #{sig.Fa}

xb = #{sig.Xb}
fb = #{sig.Fb}

xc = #{sig.Xc}
fc = #{sig.Fc}
~~~~

Alice and Carol are selected to sign the message "This is another test"

The legendre coefficients are:

~~~~
la = #{sig.La}
lc = #{sig.Lc}
~~~~

The legendre coefficients are passed to Alice and Carol who use them to 
calculate their secret scalar values:

~~~~
sa = la.Sa;
sc = lc.Sc
~~~~

Alice and Carol select their values ra, rc

~~~~
ra = #{sig.Ra}
Ra = #{sig.RRa}

rc = #{sig.Rc}
Rc = #{sig.RRc}
~~~~

The aggregate value R = R<sub>a</sub> + R<sub>c</sub>

~~~~
R =  #{sig.R}
~~~~

The value k is 

~~~~
k = #{sig.K}
~~~~

The signature contributions can now be calulated:

~~~~
Sa = #{sig.SSa}
Sc = #{sig.SSc}
~~~~

The coordinator calculates the aggregate value S = S<sub>a</sub> + S<sub>b</sub>

~~~~
S =  #{sig.S}
~~~~

The coordinator checks to see that the signature verifies:

~~~~
S.B = R + kA = 
    X: #{sig.SBX}
    Y: #{sig.SBY}
~~~~

#end method


#method Describe Unanimous sig
The signers are Alice and Bob. Each creates a key pair:

#call DescribeKey sig.KeyAlice
#call DescribeKey sig.KeyBob

The Aggregate Signature Key A = A<sub>a</sub> + A<sub>b</sub>

#call DescribeKey sig.KeyAggregate

To sign the text "This is a Test", Alice and Bob first generate their values r
which they multiply by the base point to obtain the value R<sub>i</sub>:

~~~~
Alice:
r_a =  #{sig.Ra}
R_a =  #{sig.RRa}

Bob:
r_a =  #{sig.Rb}
R_a =  #{sig.RRb}
~~~~

The aggregate value R = R<sub>a</sub> + R<sub>b</sub>

~~~~
R =  #{sig.R}
~~~~

The value k is calculated 

~~~~
k =  #{sig.K}
~~~~

Alice and Bob both calculate their signature scalar contribution:

~~~~
Alice:
S_a =  #{sig.SSa}

Bob:
S_b =  #{sig.SSb}
~~~~

The coordinator calculates the aggregate value S = S<sub>a</sub> + S<sub>b</sub>

~~~~
S =  #{sig.S}
~~~~

The coordinator checks to see that the signature verifies:

~~~~
S.B = R + kA = 
    X: #{sig.SBX}
    Y: #{sig.SBY}
~~~~
#end method


#file ExamplesAdvancedQuantum "Examples\\ExamplesAdvancedQuantum.md" CreateExamples Example
####Example: Creating a Quantum Resistant Signature Fingerprint

Alice decides to add a QRSF to her Mesh Profile. She creates
a 256 bit master secret.

~~~~
TBS: #{Example.AdvancedQuantumMasterSecret}
~~~~

To enable recovery of the master key, Alice creates five keyshares with a quorum of three:

~~~~
TBS: #{Example.AdvancedQuantumShares}
~~~~

Alice uses the master secret to derrive her private key values:

~~~~
TBS: #{Example.AdvancedQuantumPrivate}
~~~~

These values are used to generate the public key value:

~~~~
TBS: #{Example.AdvancedQuantumPublic}
~~~~

The QRSF contains the UDF fingerprint of the public key
value plus the XMSS parameters:

~~~~
TBS: #{Example.AdvancedQuantumPublicUDF}
~~~~

Alice adds the QRSF to her profile and publishes it to a Mesh Service that is enrolled
in at least one multi-party notary scheme.


#end file

#file Blahhh "Examples\\Blahhh.md" CreateExamples Example
The Recryption entry consists of Bob's address, the recryption key and the decryption
key encrypted under Bob's encryption key:


~~~~
TBS: #{Example.AdvancedRecryptionBobRecryptionEntry}
~~~~

The group administration tool creates a notification request to tell Bob that
he has been made a member of the new group and signs it using the group signature
key. The recryption entry and the notification are then sent to the recryption
service:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionAddMemberRequest}
~~~~

The notification message contains a link to the test message. When he accepts
membership of the group, Bob clicks on the link to test that his membership
has been fully provisioned. Providing an explicit test mechanism avoids the problem
that might otherwise occur in which the message spool fills up with test messages 
being posted.

Bob's Web browser requests the recryption data for the test message. The request is 
authenticated and encrypted under Bob's device keys. The plaintext of the message is:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionRequest}
~~~~

The plaintext of the response contains the additional information Bob's Web browser
needs to complete the decryption process:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionResponse}
~~~~

The Web browser decrypts the private key and uses it to calculate the decryption 
value:

~~~~
TBS: #{Example.AdvancedRecryptionDecryptionValue}
~~~~

The key agreement value is obtained by point addition of the recryption and decryption
values:
#end file
#end xclass


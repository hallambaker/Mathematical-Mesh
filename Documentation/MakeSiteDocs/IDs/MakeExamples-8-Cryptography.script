#using System.Text
#using Goedel.Mesh
#using Goedel.Protocol
#using Goedel.Utilities
#% #pragma warning disable IDE0022
#% #pragma warning disable IDE0060
#% #pragma warning disable IDE1006
#xclass ExampleGenerator CreateExamples

#method MakeCryptographyExamples CreateExamples Example
#% ExamplesThreshold(Example);
#end method


#xfile CreateExamples ExamplesThreshold "Examples\\ExamplesThreshold.md" CreateExamples Example
#% var threshold = Example.Threshold;

#### Threshold Key Generation

###### X25519

#call DescribeKeyGen threshold.KeyGenX25519


###### X448

#call DescribeKeyGen threshold.KeyGenX448

###### Ed25519

#call DescribeKeyGen threshold.KeyGenEd25519

###### Ed448

#call DescribeKeyGen threshold.KeyGenEd448

#### Threshold Decryption

###### Key Splitting X25519

#call DescribeDecryptSplitting threshold.DecryptX25519

###### Decryption X25519

#call DescribeDecryptUse threshold.DecryptX25519

###### Key Splitting X448

#call DescribeDecryptSplitting threshold.DecryptX448

###### Decryption X448

#call DescribeDecryptUse threshold.DecryptX448

#end xfile


#method DescribeDecryptUse Decrypt Decrypt

The means of encryption is unchanged. We begin by generating an ephemeral 
key pair:

~~~~
#call DescribeKey Decrypt.KeyE
~~~~

The key agreement result is given by multiplying the public key of the encryption 
pair by the secret scalar of the ephemeral key to obtain the u-coordinate of the result.

~~~~
#{Decrypt.KeyEA.XTag}: #{Decrypt.KeyEA.X}
~~~~

The u-coordinate is encoded in the usual fashion (i.e. without specifying the sign of v).

~~~~
#{Decrypt.KeyEA.Public.ToStringBase16FormatHex()}
~~~~

The first decryption contribution is generated from the secret scalar of the first key
share and the public key of the ephemeral.

The outputs from the Montgomery Ladder are:

~~~~
x_2 #{Decrypt.KeyE1.X2}
z_2 #{Decrypt.KeyE1.Z2}
x_3 #{Decrypt.KeyE1.X3}
z_3 #{Decrypt.KeyE1.Z3}
~~~~

The coordinates of the corresponding point are:

~~~~
u #{Decrypt.KeyE1.X}
v #{Decrypt.KeyE1.Y}
~~~~

The encoding of this point specifies the u coordinate and the sign (oddness) of the 
v coordinate:

~~~~
#{Decrypt.KeyE1.Public.ToStringBase16FormatHex()}
~~~~

The second decryption contribution is generated from the secret scalar of the second key
share and the public key of the ephemeral in the same way:

~~~~
u #{Decrypt.KeyE2.X}
v #{Decrypt.KeyE2.Y}
~~~~

~~~~
#{Decrypt.KeyE2.Public.ToStringBase16FormatHex()}
~~~~

To obtain the key agreement value, we add the two decryption contributions:

~~~~
u #{Decrypt.KeyE12.X}
v #{Decrypt.KeyE12.Y}
~~~~

This returns the same u coordinate value as before, allowing us to obtain the encoding 
of the key agreement value and decrypt the message.


#end method

#method DescribeDecryptSplitting Decrypt Decrypt

The encryption key pair is

~~~~
#call DescribeKey Decrypt.KeyA
~~~~

To create n key shares we first create n-1 key pairs in the normal fashion. Since 
these key pairs are only used for decryption operations, it is not necessary to 
calculate the public components:

~~~~
#call DescribeKeyPrivate Decrypt.Key1
~~~~

The secret scalar of the final key share is the secret scalar of the base key minus
the sum of the secret scalars of the other shares modulo the group order:

~~~~
Scalar_2 = (Scalar_A - Scalar_1) mod L
    = #{Decrypt.Key2.Scalar}
This is encoded as a binary integer in little endian format:
#{Decrypt.Key2.Private.ToStringBase16FormatHex()}
~~~~


#end method

#method DescribeKeyGen KeyGen KeyGen
The key parameters of the first key contribution are:

~~~~
#call DescribeKey KeyGen.Key1
~~~~

The key parameters of the second key contribution are:

~~~~
#call DescribeKey KeyGen.Key2
~~~~

The aggregate private key is:

~~~~
Scalar_A = (Scalar_1 + Scalar_2) mod L
  = #{KeyGen.KeyA.Scalar}

Encoded Aggrgate Private Key:
#{KeyGen.KeyA.Private.ToStringBase16FormatHex()}
~~~~

The aggregate public key is:

~~~~
Point_A = Point_1 + Point_2

#{KeyGen.KeyA.XTag}: #{KeyGen.KeyA.X}
#{KeyGen.KeyA.YTag}: #{KeyGen.KeyA.Y}

Encoded Public#{KeyGen.KeyA.Public.ToStringBase16FormatHex()}
~~~~

#if (KeyGen.KeyA.IsCurveX) 
Note that in this case, the unsigned representation of the key is used as
the aggregate key is intended for unsigned CurveX key agreement. If the
result is intended for use as a key contribution, the signed representation
is required.

#end if
#end method



#method DescribeKeyPrivate CurveKey Key
#{Key.Name} (#{Key.Curve})
    UDF:        #{Key.UDF}
    Scalar:     #{Key.Scalar}
    Encoded Private#{Key.Private.ToStringBase16FormatHex()}
#end method

#method DescribeKey CurveKey Key
#call DescribeKeyPrivate Key
    #{Key.XTag}: #{Key.X}
    #{Key.YTag}: #{Key.Y}
    Encoded Public#{Key.Public.ToStringBase16FormatHex()}
#end method



#file ExamplesAdvancedQuantum "Examples\\ExamplesAdvancedQuantum.md" CreateExamples Example
####Example: Creating a Quantum Resistant Signature Fingerprint

Alice decides to add a QRSF to her Mesh Profile. She creates
a 256 bit master secret.

~~~~
TBS: #{Example.AdvancedQuantumMasterSecret}
~~~~

To enable recovery of the master key, Alice creates five keyshares with a quorum of three:

~~~~
TBS: #{Example.AdvancedQuantumShares}
~~~~

Alice uses the master secret to derrive her private key values:

~~~~
TBS: #{Example.AdvancedQuantumPrivate}
~~~~

These values are used to generate the public key value:

~~~~
TBS: #{Example.AdvancedQuantumPublic}
~~~~

The QRSF contains the UDF fingerprint of the public key
value plus the XMSS parameters:

~~~~
TBS: #{Example.AdvancedQuantumPublicUDF}
~~~~

Alice adds the QRSF to her profile and publishes it to a Mesh Service that is enrolled
in at least one multi-party notary scheme.


#end file

#file Blahhh "Examples\\Blahhh.md" CreateExamples Example
The Recryption entry consists of Bob's address, the recryption key and the decryption
key encrypted under Bob's encryption key:


~~~~
TBS: #{Example.AdvancedRecryptionBobRecryptionEntry}
~~~~

The group administration tool creates a notification request to tell Bob that
he has been made a member of the new group and signs it using the group signature
key. The recryption entry and the notification are then sent to the recryption
service:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionAddMemberRequest}
~~~~

The notification message contains a link to the test message. When he accepts
membership of the group, Bob clicks on the link to test that his membership
has been fully provisioned. Providing an explicit test mechanism avoids the problem
that might otherwise occur in which the message spool fills up with test messages 
being posted.

Bob's Web browser requests the recryption data for the test message. The request is 
authenticated and encrypted under Bob's device keys. The plaintext of the message is:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionRequest}
~~~~

The plaintext of the response contains the additional information Bob's Web browser
needs to complete the decryption process:

~~~~
TBS: #{Example.AdvancedRecryptionRecryptionRecryptionResponse}
~~~~

The Web browser decrypts the private key and uses it to calculate the decryption 
value:

~~~~
TBS: #{Example.AdvancedRecryptionDecryptionValue}
~~~~

The key agreement value is obtained by point addition of the recryption and decryption
values:
#end file
#end xclass



//  Copyright (c) Comodo Group Inc. by 2017
//  
//  Permission is hereby granted, free of charge, to any person obtaining a copy
//  of this software and associated documentation files (the "Software"), to deal
//  in the Software without restriction, including without limitation the rights
//  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
//  copies of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//  
//  The above copyright notice and this permission notice shall be included in
//  all copies or substantial portions of the Software.
//  
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
//  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
//  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
//  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
//  THE SOFTWARE.
//  
//  
// This file is automatically generated from the following source files:
// Command line options: 
//     /dlexer=False
//     /dparser=False
//     /dstack=False

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using Goedel.Registry;
using Goedel.Utilities;


//
// Namespace Goedel.Tool.Version
// Class Release
//


// Types
//   TopTypeType
//       Version
//   TypeType
//       Platform
//       Description
//       Stable
//       File
//   IdType
//   NamespaceType
//       Goedel.Tool.Version
//   ClassType
//       Release
//   NameType
//       Code
//       Entries
//       Name
//       RID
//       Type
//       Text
//   TokenType

namespace Goedel.Tool.Version {


    public enum ReleaseType {
        _Top,

        Version,
        Platform,
        File,
        Description,
        Stable,

        _Label,
        _Bottom
        }    
    

    public abstract partial class _Choice {
        abstract public ReleaseType _Tag ();

		public abstract void Serialize (StructureWriter Output, bool tag);

		public virtual void Init (_Choice Parent) {
			}

		bool _Initialized = false;
		public virtual void _InitChildren (_Choice Parent) {
			Init (Parent);
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			}
        }



    public partial class Version : _Choice {
		public string					Code;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ReleaseType _Tag () {
            return ReleaseType.Version;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Version");
				}

			Output.WriteAttribute ("Code", Code);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Version");
				}			
			}
		}

    public partial class Platform : _Choice {
		public string					Name;
        public List <_Choice>           Entries = new List<_Choice> ();

        public override ReleaseType _Tag () {
            return ReleaseType.Platform;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			foreach (var Sub in Entries) {
				Sub._InitChildren (this);
				}
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Platform");
				}

			Output.WriteAttribute ("Name", Name);
			Output.StartList ("");
			foreach (_Choice _e in Entries) {
				_e.Serialize (Output, true);
				}
			Output.EndList ("");
			if (tag) {
				Output.EndElement ("Platform");
				}			
			}
		}

    public partial class File : _Choice {
		public string					Name;
		public string					RID;
		public string					Type;

        public override ReleaseType _Tag () {
            return ReleaseType.File;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("File");
				}

			Output.WriteAttribute ("Name", Name);
			Output.WriteAttribute ("RID", RID);
			Output.WriteAttribute ("Type", Type);
			if (tag) {
				Output.EndElement ("File");
				}			
			}
		}

    public partial class Description : _Choice {
		public List <System.String>			Text = new List <System.String> (); 

        public override ReleaseType _Tag () {
            return ReleaseType.Description;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Description");
				}

			foreach (string _s in Text) {
				Output.WriteAttribute ("Text",_s);
				}
			if (tag) {
				Output.EndElement ("Description");
				}			
			}
		}

    public partial class Stable : _Choice {

        public override ReleaseType _Tag () {
            return ReleaseType.Stable;
            }

		public override void _InitChildren (_Choice Parent) {
			Init (Parent);
			}

		public override void Serialize (StructureWriter Output, bool tag) {

			if (tag) {
				Output.StartElement ("Stable");
				}

			if (tag) {
				Output.EndElement ("Stable");
				}			
			}
		}

    class _Label : _Choice {
        public REF<_Choice>            Label;

		// This method is never called. It exists only to prevent a warning when a
		// Schema does not contain a ChoiceREF element.
        public void Reach() {
            Label = null;
            }

        public override ReleaseType _Tag () {
            return ReleaseType._Label;
            }

		public override void Serialize (StructureWriter Output, bool tag) {
			Output.WriteId ("ID", Label.ToString());
			}
        }


    public enum StateCode {  
        _Start,
        _Choice,
        _End,

		Version_Start,
		Version__Code,				
		Version__Entries,				
		Platform_Start,
		Platform__Name,				
		Platform__Entries,				
		File_Start,
		File__Name,				
		File__RID,				
		File__Type,				
		Description_Start,
		Description__Text,				
		Stable_Start,
        }


    struct _StackItem {
        public StateCode   State;
        public Goedel.Tool.Version._Choice     Token;
        }

    public partial class Release : Goedel.Registry.Parser{
        public List <Goedel.Tool.Version._Choice>        Top;
        public Registry	<Goedel.Tool.Version._Choice>	Registry;



        bool _StartOfEntry;
        public bool StartOfEntry {
            get {return _StartOfEntry;}
            private set { _StartOfEntry = value; }
            }

        StateCode								State;
        Goedel.Tool.Version._Choice				Current;
        List <_StackItem>						Stack;


        public static Release Parse(string File, Goedel.Registry.Dispatch Options) {
            var Result = new Release();
            Result.Options = Options;

            using (Stream infile =
                        new FileStream(File, FileMode.Open, FileAccess.Read)) {
                Lexer Schema = new Lexer(File);
                Schema.Process(infile, Result);
                }
			Result._InitChildren ();

            return Result;
            }

		bool _Initialized = false;
		public virtual void _InitChildren () {
			if (_Initialized) {
				return;
				}
			_Initialized = true;
			foreach (var Entry in Top) {
				Entry._InitChildren (null);
				}
			}

        public Release() {
            Top = new List<Goedel.Tool.Version._Choice> () ;
            Registry = new Registry <Goedel.Tool.Version._Choice> ();
            State = StateCode._Start;
            Stack = new List <_StackItem> ();
            _StartOfEntry = true;




            }




        private Goedel.Tool.Version._Choice New_Choice(string Label) {
            switch (Label) {

                case "Version": return NewVersion();
                case "Platform": return NewPlatform();
                case "File": return NewFile();
                case "Description": return NewDescription();
                case "Stable": return NewStable();

				}

            throw new NotFoundReserved ("Reserved word not recognized \"" + Label + "\"");
            }



        private Goedel.Tool.Version.Version NewVersion() {
            Goedel.Tool.Version.Version result = new Goedel.Tool.Version.Version();
            Push (result);
            State = StateCode.Version_Start;
            return result;
            }


        private Goedel.Tool.Version.Platform NewPlatform() {
            Goedel.Tool.Version.Platform result = new Goedel.Tool.Version.Platform();
            Push (result);
            State = StateCode.Platform_Start;
            return result;
            }


        private Goedel.Tool.Version.File NewFile() {
            Goedel.Tool.Version.File result = new Goedel.Tool.Version.File();
            Push (result);
            State = StateCode.File_Start;
            return result;
            }


        private Goedel.Tool.Version.Description NewDescription() {
            Goedel.Tool.Version.Description result = new Goedel.Tool.Version.Description();
            Push (result);
            State = StateCode.Description_Start;
            return result;
            }


        private Goedel.Tool.Version.Stable NewStable() {
            Goedel.Tool.Version.Stable result = new Goedel.Tool.Version.Stable();
            Push (result);
            State = StateCode.Stable_Start;
            return result;
            }


        static Goedel.Tool.Version.ReleaseType _Reserved(string Label) {
            switch (Label) {

                case "Version": return Goedel.Tool.Version.ReleaseType.Version;
                case "Platform": return Goedel.Tool.Version.ReleaseType.Platform;
                case "File": return Goedel.Tool.Version.ReleaseType.File;
                case "Description": return Goedel.Tool.Version.ReleaseType.Description;
                case "Stable": return Goedel.Tool.Version.ReleaseType.Stable;

                }
            return Goedel.Tool.Version.ReleaseType._Bottom;
            }


		public void Serialize (TextWriter Output) {
			Serialize (Output, OutputFormat.Goedel);
			}

		public void Serialize (TextWriter Output, OutputFormat OutputFormat) {

			StructureWriter StructureWriter = StructureWriter.GetStructureWriter (Output, OutputFormat);
			StructureWriter.StartDocument ();
			foreach (Goedel.Tool.Version._Choice Entry in Top) {
				Entry.Serialize (StructureWriter, true);
				}
			StructureWriter.EndDocument ();
			}


        void Push (Goedel.Tool.Version._Choice Token) {
            _StackItem Item = new _StackItem ();
            Item.State = State;
            Item.Token = Current;

            Stack.Add (Item);

            //Console.WriteLine ("$$$$PUSH {0}", Current);

            Current = Token;
            }

        void Pop () {
			Assert.False (Stack.Count == 0, InternalError.Throw);

            _StackItem Item = Stack[Stack.Count -1];
            State = Item.State;
            Current = Item.Token;

            Stack.RemoveAt (Stack.Count -1 ) ;

            //Console.WriteLine ("$$$$POP {0}", Current);
            }



        public override void Process(TokenType Token, Position Position, string Text) {

            if ((Token == TokenType.SEPARATOR) |
                (Token == TokenType.NULL) |
                (Token == TokenType.COMMENT)) {
				return;
				}
			Assert.False (Token == TokenType.INVALID, InvalidToken.Throw);

            bool Represent = true;

            while (Represent) {
                //Console.WriteLine ("    {3}: {0} {1} '{2}'", Token, Position, Text, State);


                Represent = false;
                switch (State) {
                    case StateCode._Start:                 //      BEGIN
                        if (Token == TokenType.BEGIN) {
                            State = StateCode._Choice;
                            break;
                            }
                        else {
							throw new ExpectedStart ();
							}

                    case StateCode._Choice:                //      LABEL Class | END
                        if (Token == TokenType.LABEL) {
                            Goedel.Tool.Version.ReleaseType LabelType = _Reserved (Text);
                            if (false |
									(LabelType == Goedel.Tool.Version.ReleaseType.Version)) {
                                Top.Add(New_Choice(Text));
                                }
                            else {
                                throw new Expected("Parser Error Expected [Class]");
                                }
                            break;
                            }
                        if (Token == TokenType.END) {
                            State = StateCode._End;
                            break;
                            }
                        else {
							throw new ExpectedClass();
							}

                    case StateCode._End: {                  //      -
                        throw new TooManyClose();
						}

                    case StateCode.Version_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Version.Version Current_Cast = (Goedel.Tool.Version.Version)Current;
                            Current_Cast.Code = Text;
                            State = StateCode.Version__Code;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Version__Code:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Version__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Version__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Version.Version Current_Cast = (Goedel.Tool.Version.Version)Current;
                            Goedel.Tool.Version.ReleaseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Version.ReleaseType.Platform) |
									(LabelType == Goedel.Tool.Version.ReleaseType.Description) |
									(LabelType == Goedel.Tool.Version.ReleaseType.Stable) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [Platform Description Stable ]");
								}
							}
                        break;


                    case StateCode.Platform_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Version.Platform Current_Cast = (Goedel.Tool.Version.Platform)Current;
                            Current_Cast.Name = Text;
                            State = StateCode.Platform__Name;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.Platform__Name:

                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Platform__Entries;
                            }
                        else {
							Pop ();
                            Represent = true;
                            }
                        break;
                    case StateCode.Platform__Entries: 
                        if (Token == TokenType.END) {
                            Pop();
                            break;
                            }

						// Parser transition for LIST $$$$$

                        else if (Token == TokenType.LABEL) {
							Goedel.Tool.Version.Platform Current_Cast = (Goedel.Tool.Version.Platform)Current;
                            Goedel.Tool.Version.ReleaseType LabelType = _Reserved (Text);
                            if ( false |
									(LabelType == Goedel.Tool.Version.ReleaseType.File) ) {
                                Current_Cast.Entries.Add (New_Choice(Text));
                                }
                            else {
								throw new Expected ("Parser Error Expected [File ]");
								}
							}
                        break;


                    case StateCode.File_Start:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Version.File Current_Cast = (Goedel.Tool.Version.File)Current;
                            Current_Cast.Name = Text;
                            State = StateCode.File__Name;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.File__Name:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Version.File Current_Cast = (Goedel.Tool.Version.File)Current;
                            Current_Cast.RID = Text;
                            State = StateCode.File__RID;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.File__RID:
                        if (Token == TokenType.STRING) {
                            Goedel.Tool.Version.File Current_Cast = (Goedel.Tool.Version.File)Current;
                            Current_Cast.Type = Text;
                            State = StateCode.File__Type;
                            break;
                            }
                        throw new Expected("Expected String");

                    case StateCode.File__Type:
                        Pop ();
                        Represent = true; 
                        break;
                    case StateCode.Description_Start:
                        if (Token == TokenType.BEGIN) {
                            State = StateCode.Description__Text;
                            break;
                            }
                        else {
                            Pop();
                            Represent = true;
                            break;
                            }
                    case StateCode.Description__Text:
                       if (Token == TokenType.END) {
                            Pop();
                            break;
                            }
                       else if (Token == TokenType.TEXT) {
                            Goedel.Tool.Version.Description Current_Cast = (Goedel.Tool.Version.Description)Current;
                            Current_Cast.Text.Add (Text);
                            break;							
                            }
                       throw new Expected("Expected Text");


                    case StateCode.Stable_Start:
                        Pop ();
                        Represent = true; 
                        break;

                    default: {
                        throw new UnreachableCode();
						}
                    }
                }
            }
        }
	}



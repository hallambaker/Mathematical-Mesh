<?xml version='1.0'?>
<!DOCTYPE rfc SYSTEM 'rfc2629.dtd'>
<rfc ipr="trust200902" docName="draft-hallambaker-mesh-dare-06" category="info">
<?rfc toc="yes"?>  
<?rfc symrefs="yes"?>  
<?rfc sortrefs="yes"?>  
<?rfc compact="yes"?>  
<?rfc subcompact="no"?>  
<front>
<title abbrev="Mesh: Data At Rest Encryption">Mathematical Mesh 3.0 Part III : Data At Rest Encryption (DARE)</title>
<author fullname="Phillip Hallam-Baker" initials="P. M." surname="Hallam-Baker">
<address>
<email>phill@hallambaker.com</email>
</address>
</author>
<date day="13" month="November" year="2019"/>
<area/>
<workgroup/>
<abstract>
<t>
This document describes the Data At Rest Encryption (DARE) Envelope and Container syntax. </t>
<t>
The DARE Envelope syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary content data.</t>
<t>
The DARE Container syntax describes an append-only sequence of entries, each containing a DARE Envelope. DARE Containers may support cryptographic integrity verification of the entire data container content by means of a Merkle tree. </t>
<t>
[Note to Readers]</t>
<t>
Discussion of this draft takes place on the MATHMESH mailing list (mathmesh@ietf.org), which is archived at https://mailarchive.ietf.org/arch/search/?email_list=mathmesh.</t>
<t>
This document is also available online at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">
http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>
.</t>
</abstract>
</front>
<middle>
<section title="Introduction" anchor="s-1">
<t>
This document describes the Data At Rest Encryption (DARE) Envelope and Container Syntax. The DARE Envelope syntax is used to digitally sign, digest, authenticate, or encrypt arbitrary message content. The DARE Container syntax describes an append-only sequence of data frames, each containing a DARE Envelope that supports efficient incremental signature and encryption.</t>
<t>
The DARE Envelope Syntax is based on a subset of the JSON Web Signature <xref target="RFC7515">
</xref>
 and JSON Web Encryption <xref target="RFC7516">
</xref>
 standards and shares many fields and semantics. The processing model and data structures have been streamlined to remove alternative means of specifying the same content and to enable multiple data sequences to be signed and encrypted under a single master encryption key without compromise to security.</t>
<t>
A DARE Envelope consists of a Header, Payload and an optional Trailer. To enable single pass encoding and decoding, the Header contains all the information required to perform cryptographic processing of the Payload and authentication data (digest, MAC, signature values) MAY be deferred to the Trailer section.</t>
<t>
A DARE Container is an append-only log format consisting of a sequence of frames. Cryptographic enhancements (signature, encryption) may be applied to individual frames or to sets of frames. Thus, a single key exchange may be used to provide a master key to encrypt multiple frames and a single signature may be used to authenticate all the frames in the container up to and including the frame in which the signature is presented.</t>
<t>
The DARE Envelope syntax may be used either as a standalone cryptographic message syntax or as a means of presenting a single DARE Container frame together with the complete cryptographic context required to verify the contents and decrypt them.</t>
<section title="Encryption and Integrity" anchor="s-1_1">
<t>
A key innovation in the DARE Envelope Syntax is the separation of key exchange and data encryption operations so that a Master Key (MK) established in a single exchange to be applied to multiple data sequences. This means that a single public key operation MAY be used to encrypt and/or authenticate multiple parts of the same DARE Envelope or multiple frames in a DARE Container.</t>
<t>
To avoid reuse of the key and to avoid the need to communicate separate IVs, each octet sequence is encrypted under a different encryption key (and IV if required) derived from the Master Key by means of a salt that is unique for each octet sequence that is encrypted. The same approach is used to generate keys for calculating a MAC over the octet sequence if required. This approach allows encryption and integrity protections to be applied to the envelope payload, to header or trailer fields or to application defined Enhanced Data Sequences in the header or trailer. </t>
<section title="Key Exchange" anchor="s-1_1_1">
<t>
Traditional cryptographic containers describe the application of a single key exchange to encryption of a single octet sequence. Examples include PCKS#7/CMS <xref target="RFC2315">
</xref>
, OpenPGP <xref target="RFC4880">
</xref>
 and JSON Web Encryption <xref target="RFC7516">
</xref>
.</t>
<t>
To encrypt data using RSA, the encoder first generates a random encryption key and initialization vector (IV). The encryption key is encrypted under the public key of each recipient to create a per-recipient decryption entry. The encryption key, plaintext and IV are used to generate the ciphertext (figure 1).</t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
Monolithic Key Exchange and Encrypt</postamble>
</figure>
<t>
This approach is adequate for the task of encrypting a single octet stream. It is less than satisfactory when encrypting multiple octet streams or very long streams for which a rekeying operation is desirable. </t>
<t>
In the DARE approach, key exchange and key derivation are separate operations and keys MAY be derived for encryption or integrity purposes or both. A single key exchange MAY be used to derive keys to apply encryption and integrity enhancements to multiple data sequences.</t>
<t>
The DARE key exchange begins with the same key exchange used to produce the CEK in JWE but instead of using the CEK to encipher data directly, it is used as one of the inputs to a Key Derivation Function (KDF) that is used to derive parameters for each block of data to be encrypted. To avoid the need to introduce additional terminology, the term 'CEK' is still used to describe the output of the key agreement algorithm (including key unwrapping if required) but it is more appropriately described as a Master Key (figure 2).</t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
Exchange of Master Key</postamble>
</figure>
<t>
A Master Key may be used to encrypt any number of data items. Each data item is encrypted under a different encryption key and IV (if required). This data is derived from the Master Key using the HKDF function <xref target="RFC5869">
</xref>
 using a different salt for each data item and separate info tags for each cryptographic function (figure 3).</t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
Data item encryption under Master Key and per-item salt.</postamble>
</figure>
<t>
This approach to encryption offers considerably greater flexibility allowing the same format for data item encryption to be applied at the transport, message or field level.</t>
</section>
<section title="Data Erasure" anchor="s-1_1_2">
<t>
Each encrypted DARE Envelope specifies a unique Master Salt value of at least 128 bits which is used to derive the salt values used to derive cryptographic keys for the envelope payload and annotations.</t>
<t>
Erasure of the Master Salt value MAY be used to effectively render the envelope payload and annotations undecipherable without altering the envelope payload data. The work factor for decryption will be O(2^128) even if the decryption key is compromised.</t>
</section>
</section>
<section title="Signature" anchor="s-1_2">
<t>
As with encryption, DARE Envelope signatures MAY be applied to an individual envelope or a sequence of envelope. </t>
<section title="Signing Individual Plaintext Envelopes" anchor="s-1_2_1">
<t>
When an individual plaintext envelope is signed, the digest value used to create the signature is calculated over the binary value of the payload data. That is, the value of the payload before the encoding (Base-64, JSON-B) is applied. </t>
</section>
<section title="Signing Individual Encrypted Envelopes" anchor="s-1_2_2">
<t>
When an individual plaintext envelope is signed, the digest value used to create the signature is calculated over the binary value of the payload data. That is, the value of the payload after encryption but before the encoding (Base-64, JSON-B) is applied. </t>
<t>
Use of signing and encryption in combination presents the risk of subtle attacks depending on the order in which signing and encryption take place <xref target="Davis2001">
</xref>
.</t>
<t>
Na?ve approaches in which an envelope is encrypted and then signed present the possibility of a surreptitious forwarding attack. For example, Alice signs an envelope and sends it to Mallet who then strips off Alice's signature and sends the envelope to Bob.  </t>
<t>
Na?ve approaches in which an envelope is signed and then encrypted present the possibility of an attacker claiming authorship of a ciphertext. For example, Alice encrypts a ciphertext for Bob and then signs it. Mallet then intercepts the envelope and sends it to Bob.</t>
<t>
While neither attack is a concern in all applications, both attacks pose potential hazards for the unwary and require close inspection of application protocol design to avoid exploitation.</t>
<t>
To prevent these attacks, each signature on an envelope that is signed and encrypted MUST include a witness value that is calculated by applying a MAC function to the signature value as described in section XXX.</t>
</section>
<section title="Signing sequences of envelopes" anchor="s-1_2_3">
<t>
To sign multiple envelopes with a single signature, we first construct a Merkle tree of the envelope payload digest values and then sign the root of the Merkle tree.</t>
<t>
[This is not yet implemented but will be soon.]</t>
</section>
</section>
<section title="Container" anchor="s-1_3">
<t>
DARE Container is a message and file syntax that allows a sequence of data frames to be represented with cryptographic integrity, signature, and encryption enhancements to be constructed in an append only format.</t>
<t>
The format is designed to meet the requirements of a wide range of use cases including:</t>
<t><list style="symbols">
<t>
Recording transactions in persistent storage.</t>
<t>
Synchronizing transaction logs between hosts.</t>
<t>
File archive.</t>
<t>
Message spool.</t>
<t>
Signing and encrypting single data items.</t>
<t>
Incremental encryption and authentication of server logs.</t>
</list></t>
<section title="Container Format" anchor="s-1_3_1">
<t>
A Container consists of a sequence of variable length Frames. Each frame consists of a forward length indicator, the framed data and a reverse length indicator. The reverse length indicator is written out backwards allowing the length and thus the frame to be read in the reverse direction: </t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
JBCD Bidirectional Frame</postamble>
</figure>
<t>
Each frame contains a single DARE Envelope consisting of a Header, Payload and Trailer (if required). The first frame in a container describes the container format options and defaults. These include the range of encoding options for frame metadata supported and the container profiles to which the container conforms. </t>
<t>
All internal data formats support use of pointers of up to 64 bits allowing containers of up to 18 exabytes to be written. </t>
<t>
Five container types are currently specified:</t>
<t><list style="hanging">
<t hangText="Simple">
The container does not provide any index or content integrity checks.</t>
<t hangText="Tree">
Frame headers contain entries that specify the start position of previous frames at the apex of the immediately enclosing binary tree. This enables efficient random access to any frame in the file.</t>
<t hangText="Digest">
Each frame trailer contains a PayloadDigest field. Modification of the payload will cause verification of the PayloadDigest value to fail on that frame.</t>
<t hangText="Chain">
Each frame trailer contains PayloadDigest and ChainDigest fields allowing modifications to the payload data to be detected. Modification of the payload will cause verification of the PayloadDigest value to fail on that frame and verification of the ChainDigest value to fail on all subsequent frames.</t>
<t hangText="Merkle Tree">
Frame headers contain entries that specify the start position of previous frames at the apex of the immediately enclosing binary tree. Frame Trailers contain TreeDigestPartial&nbsp;and TreeDigestFinal&nbsp;entries forming a Merkle digest tree.</t>
</list></t>
</section>
<section title="Write" anchor="s-1_3_2">
<t>
In normal circumstances, Containers are written as an append only log. As with Envelopes, integrity information (payload digest, signatures) is written to the entry trailer. Thus, large payloads may be written without the need to buffer the payload data provided that the content length is known in advance.</t>
<t>
Should exceptional circumstances require, Container entries MAY be erased by overwriting the Payload and/or parts of the Header content without compromising the ability to verify other entries in the container. If the entry Payload is encrypted, it is sufficient to erase the container salt value to render the container entry effectively inaccessible (though recovery might still be possible if the original salt value can be recovered from the storage media.</t>
</section>
<section title="Encryption and Authentication" anchor="s-1_3_3">
<t>
Frame payloads and associated attributes MAY be encrypted and/or authenticated in the same manner as Envelopes. </t>
<t>
Incremental encryption is supported allowing encryption parameters from a single public key exchange operation to be applied to encrypt multiple frames. The public key exchange information is specified in the first encrypted frame and subsequent frames encrypted under those parameters specify the location at which the key exchange information is to be found by means of the ExchangePosition field which MUST specify a location that is earlier in the file.</t>
<t>
To avoid cryptographic vulnerabilities resulting from key re-use, the DARE key exchange requires that each encrypted sequence use an encryption key and initialization vector derived from the master key established in the public key exchange by means of a unique salt.</t>
<t>
Each Envelope and by extension, each Container frame MUST specify a unique salt value of at least 128 bits. Since the encryption key is derived from the salt value by means of a Key Derivation Function, erasure of the salt MAY be used as a means of rendering the payload plaintext value inaccessible without changing the payload value. </t>
</section>
<section title="Integrity and Signature" anchor="s-1_3_4">
<t>
Signatures MAY be applied to a payload digest, the final digest in a chain or tree. The chain and tree digest modes allow a single signature to be used to authenticate all frame payloads in a container.</t>
<t>
The tree signature mode is particularly suited to applications such as file archives as it allows files to be verified individually without requiring the signer to sign each individually. Furthermore, in applications such as code signing, it allows a single signature to be used to verify both the integrity of the code and its membership of the distribution.</t>
<t>
As with DARE Envelope, the signature mechanism does not specify the interpretation of the signature semantics. The presence of a signature demonstrates that the holder of the private key applied it to the specified digest value but not their motive for doing so. Describing such semantics is beyond the scope of this document and is deferred to future work.</t>
</section>
<section title="Redaction" anchor="s-1_3_5">
<t>
The chief disadvantage of using an append-only format is that containers only increase in size. In many applications, much of the data in the container becomes redundant or obsolete and a process analogous to garbage collection is required. This process is called redaction.</t>
<t>
The simplest method of redaction is to create a new container and sequentially copy each entry from the old container to the new, discarding redundant frames and obsolete header information. </t>
<t>
For example, partial index records may be consolidated into a single index record placed in the last frame of the container. Unnecessary signature and integrity data may be discarded and so on.</t>
<t>
While redaction could in principle be effected by moving data in-place in the existing container, supporting this approach in a robust fashion is considerably more complex as it requires backward references in subsequent frames to be overridden as each frame is moved. </t>
</section>
<section title="Alternative approaches" anchor="s-1_3_6">
<t>
Many file proprietary formats are in use that support some or all of these capabilities but only a handful have public, let alone open, standards. DARE Container is designed to provide a superset of the capabilities of existing message and file syntaxes, including:</t>
<t><list style="symbols">
<t>
Cryptographic Message Syntax <xref target="RFC5652">
</xref>
 defines a syntax used to digitally sign, digest, authenticate, or encrypt arbitrary message content.</t>
<t>
The.ZIP File Format specification <xref target="ZIPFILE">
</xref>
 developed by Phil Katz. </t>
<t>
The BitCoin Block chain <xref target="BLOCKCHAIN">
</xref>
.</t>
<t>
JSON Web Encryption and JSON Web Signature</t>
</list></t>
<t>
Attempting to make use of these specifications in a layered fashion would require at least three separate encoders and introduce unnecessary complexity. Furthermore, there is considerable overlap between the specifications providing multiple means of achieving the same ends, all of which must be supported if decoders are to work reliably.</t>
</section>
<section title="Efficiency" anchor="s-1_3_7">
<t>
Every data format represents a compromise between different concerns, in particular:</t>
<t><list style="hanging">
<t hangText="Compactness">
The space required to record data in the encoding.</t>
<t hangText="Memory Overhead">
The additional volatile storage (RAM) required to maintain indexes etc. to support efficient retrieval operations.</t>
<t hangText="Number of Operations">
The number of operations required to retrieve data from or append data to an existing encoded sequence.</t>
<t hangText="Number of Disk Seek Operations">
Optimizing the response time of magnetic storage media to random access read requests has traditionally been one of the central concerns of database design. The DARE Container format is designed to the assumption that this will cease to be a concern as solid state media replaces magnetic.</t>
</list></t>
<t>
While the cost of storage of all types has declined rapidly over the past decades, so has the amount of data to be stored. DARE Container represents a pragmatic balance of these considerations for current technology. In particular, since payload volumes are likely to be very large, memory and operational efficiency are considered higher priorities than compactness.</t>
</section>
</section>
</section>
<section title="Definitions" anchor="s-2">
<section title="Related Specifications" anchor="s-2_1">
<t>
The DARE Envelope and Container formats are based on the following existing standards and specifications.</t>
<t><list style="hanging">
<t hangText="Object serialization">
The JSON-B <xref target="draft-hallambaker-jsonbcd">
</xref>
 encoding is used for object serialization. This encoding is an extension of the JavaScript Object Notation (JSON) <xref target="RFC7159">
</xref>
.</t>
<t hangText="Message syntax">
The cryptographic processing model is based on JSON Web Signature (JWS) <xref target="RFC7515">
</xref>
, JSON Web Encryption (JWE) <xref target="RFC7516">
</xref>
 and JSON Web Key (JWK) <xref target="RFC7517">
</xref>
.</t>
<t hangText="Cryptographic primitives.">
The HMAC-based Extract-and-Expand Key Derivation Function <xref target="RFC5869">
</xref>
 and Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm <xref target="RFC3394">
</xref>
 are used.</t>
<t>
The Uniform Data Fingerprint method of presenting data digests is used for key identifiers and other purposes <xref target="draft-hallambaker-mesh-udf">
</xref>
.</t>
<t hangText="Cryptographic algorithms">
The cryptographic algorithms and identifiers described in JSON Web Algorithms (JWA) <xref target="RFC7518">
</xref>
 are used together with additional algorithms as defined in the JSON Object Signing and Encryption IANA registry <xref target="IANAJOSE">
</xref>
.</t>
</list></t>
</section>
<section title="Requirements Language" anchor="s-2_2">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119">
</xref>
.</t>
</section>
<section title="Defined terms" anchor="s-2_3">
<t>
The terms "Authentication Tag", "Content Encryption Key", "Key Management Mode", "Key Encryption", "Direct Key Agreement", "Key Agreement with Key Wrapping" and "Direct Encryption" are defined in the JWE specification <xref target="RFC7516">
</xref>
.</t>
<t>
The terms "Authentication", "Ciphertext", "Digital Signature", "Encryption", "Initialization Vector (IV)", "Message Authentication Code (MAC)", "Plaintext" and "Salt" are defined by the Internet Security Glossary, Version 2 <xref target="RFC4949">
</xref>
. </t>
<t><list style="hanging">
<t hangText="Annotated Envelope">
A DARE Envelope that contains an Annotations field with at least one entry.</t>
<t hangText="Authentication Data">
A Message Authentication Code or authentication tag.</t>
<t hangText="Complete Envelope">
A DARE envelope that contains the key exchange information necessary for the intended recipient(s) to decrypt it.</t>
<t hangText="Detached Envelope">
A DARE envelope that does not contain the key exchange information necessary for the intended recipient(s) to decrypt it.</t>
<t hangText="Encryption Context">
The master key, encryption algorithms and associated parameters used to generate a set of one or more enhanced data sequences.</t>
<t hangText="Encoded data sequence (EDS)">
A sequence consisting of a salt, content data and authentication data (if required by the encryption context).</t>
<t hangText="Enhancement">
Applying a cryptographic operation to a data sequence. This includes encryption, authentication and both at the same time.</t>
<t hangText="Generator">
The party that generates a DARE envelope.</t>
<t hangText="Group Encryption Key">
A key used to encrypt data to be read by a group of users. This is typically achieved by means of some form of proxy re-encryption or distributed key generation.</t>
<t hangText="Group Encryption Key Identifier">
A key identifier for a group encryption key.</t>
<t hangText="Master Key (MK)">
The master secret from which keys are derived for authenticating enhanced data sequences.</t>
<t hangText="Recipient">
Any party that receives and processes at least some part of a DARE envelope.</t>
<t hangText="Related Envelope">
A set of DARE envelopes that share the same key exchange information and hence the same Master Key.</t>
<t hangText="Uniform Data Fingerprint (UDF)">
The means of presenting the result of a cryptographic digest function over a data sequence and content type identifier specified in the Uniform Data Fingerprint specification <xref target="draft-hallambaker-mesh-udf">
</xref>
</t>
</list></t>
</section>
</section>
<section title="DARE Envelope Architecture" anchor="s-3">
<t>
A DARE Envelope is a sequence of three parts:</t>
<t><list style="hanging">
<t hangText="Header">
A JSON object containing information a reader requires to begin processing the envelope.</t>
<t hangText="Payload">
An array of octets.</t>
<t hangText="Trailer">
A JSON object containing information calculated from the envelope payload.</t>
</list></t>
<t>
For example, the following sequence is a JSON encoded Envelope with an empty header, a payload of zero length and an empty trailer:</t>
<figure anchor="s-3-9" suppress-title="true">
<artwork>
<![CDATA[[ {}, "", {} ]]]></artwork>
</figure>
<t>
DARE Envelopes MAY be encoded using JSON serialization or a binary serialization for greater efficiency.</t>
<t><list style="hanging">
<t hangText="JSON">
Offers compatibility with applications and libraries that support JSON. Payload data is encoded using Base64 incurring a 33% overhead.</t>
<t hangText="JSON-B">
A superset of JSON encoding that permits binary data to be encoded as a sequence of length-data segments. This avoids the Base64 overhead incurred by JSON encoding. Since JSON-B is a superset of JSON encoding, an application can use a single decoder for either format.</t>
<t hangText="JSON-C">
A superset of JSON-C which provides additional efficiency by allowing field tags and other repeated string data to be encoded by reference to a dictionary. Since JSON-C is a superset of JSON and JSON-B encodings, an application can use a single decoder for all three formats.</t>
</list></t>
<t>
DARE Envelope processors MUST support JSON serialization and SHOULD support JSON-B serialization. </t>
<section title="Processing Considerations" anchor="s-3_1">
<t>
The DARE Envelope Syntax supports single pass encoding and decoding without buffering of data. All the information required to begin processing a DARE envelope (key agreement information, digest algorithms), is provided in the envelope header. All the information that is derived from envelope processing (authentication codes, digest values, signatures) is presented in the envelope trailer.</t>
<t>
The choice of envelope encoding does not affect the semantics of envelope processing. A DARE Envelope MAY be reserialized under the same serialization or converted from any of the specified serialization to any other serialization without changing the semantics or integrity properties of the envelope.</t>
</section>
<section title="Content Metadata and Annotations" anchor="s-3_2">
<t>
A header MAY contain header fields describing the payload content. These include:</t>
<t><list style="hanging">
<t hangText="ContentType">
Specifies the IANA Media Type <xref target="RFC6838">
</xref>
.</t>
<t hangText="Annotations">
A list of Encoded Data Sequences that provide application specific annotations to the envelope.</t>
</list></t>
<t>
For example, consider the following mail message: </t>
<figure anchor="s-3_2-7" suppress-title="true">
<artwork>
<![CDATA[From: Alice@example.com
To: bob@example.com
Subject: TOP-SECRET Product Launch Today!

The CEO told me the product launch is today. Tell no-one!]]></artwork>
</figure>
<t>
Existing encryption approaches require that header fields such as the subject line be encrypted  with the body of the message or not encrypted at all. Neither approach is satisfactory. In this example, the subject line gives away important information that the sender probably assumed would be encrypted. But if the subject line is encrypted together with the message body, a mail client must retrieve at least part of the message body to provide a  'folder' view. </t>
<t>
The plaintext form of the equivalent DARE Message encoding is: </t>
<figure anchor="s-3_2-10" suppress-title="true">
<artwork>
<![CDATA[[{
    "Annotations":["iAEBiBdGcm9tOiBBbGljZUBleGFtcGxlLmNvbYgA",
      "iAECiBNUbzogYm9iQGV4YW1wbGUuY29tiAA",
      "iAEDiClTdWJqZWN0OiBUT1AtU0VDUkVUIFByb2R1Y3QgTGF1bmNoIFRvZGF5
  IYgA"
      ],
    "ContentMetaData":"ewogICJjdHkiOiAiYXBwbGljYXRpb24vZXhhbXBsZS1t
  YWlsIn0"},
  "VGhlIENFTyB0b2xkIG1lIHRoZSBwcm9kdWN0IGxhdW5jaCBpcyB0b2RheS4gVGVs
  bCBuby1vbmUh"
  ]]]></artwork>
</figure>
<t>
This contains the same information as before but the mail message headers are  now presented as a list of Encoded Data Sequences. </t>
</section>
<section title="Encoded Data Sequence" anchor="s-3_3">
<t>
An encoded data sequence (EDS) is a sequence of octets that encodes a data sequence according to cryptographic enhancements specified in the context in which it is presented. An EDS MAY be encrypted and MAY be authenticated by means of a MAC. The keys and other cryptographic parameters used to apply these enhancements are derived from the cryptographic context and a Salt prefix specified in the EDS itself.</t>
<t>
An EDS sequence contains exactly three binary fields encoded in JSON-B serialization as follows:</t>
<t><list style="hanging">
<t hangText="Salt Prefix">
A sequence of octets used to derive the encryption key, Initialization Vector and MAC key as required.</t>
<t hangText="Body">
The plaintext or encrypted content.</t>
<t hangText="Authentication Tag">
The authentication code value in the case that the cryptographic context specifies use of authenticated encryption or a MAC, otherwise is a zero-length field.</t>
</list></t>
<t>
Requiring all three fields to be present, even in cases where they are unnecessary simplifies processing at the cost of up to six additional data bytes.</t>
<t>
The encoding of the 'From' header of the previous example as a plaintext EDS is as follows: </t>
<figure anchor="s-3_3-11" suppress-title="true">
<artwork>
<![CDATA[88 01 
  01 
88 17 
  46 72 6f 6d 3a 20 41 6c   69 63 65 40 65 78 61 6d 
  70 6c 65 2e 63 6f 6d 
88 00 

]]></artwork>
</figure>
</section>
<section title="Encryption and Integrity" anchor="s-3_4">
<t>
Encryption and integrity protections MAY be applied to any DARE Envelope Payload and Annotations.</t>
<t>
The following is an encrypted version of the message shown earlier.  The payload and annotations have both increased in size as a result of the block cipher padding. The header now includes Recipients and Salt fields to enable the content to be decoded. </t>
<figure anchor="s-3_4-3" suppress-title="true">
<artwork>
<![CDATA[[{
    "enc":"A256CBC",
    "Salt":"4uAhX5oPNlWh8tWj_Dgu-g",
    "Annotations":["iAEBiCBPEaaoa8_ol6BuE2lw06GaA5dz4_uW5O7VyhzVUQKT
  kA",
      "iAECiCCc4_jLmfR1nXJwFn8Ku_oqtfSfsAwWJBUipiYSddFLOg",
      "iAEDiDC3aq4AFxgZ_WzP7X9mfKDSrt-kxNupK8kf26jFv7QKyvgOjyV7szs8
  YbYw8peBfgw"
      ],
    "recipients":[{
        "kid":"MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
        "epk":{
          "PublicKeyECDH":{
            "crv":"Ed25519",
            "Public":"0ILRnN26hTzxTXcLwbJqzNqY7_GriX8tVSu3HwFdLKA"}},
        "wmk":"s3a9we6L17l9iW8mGkdvumaTF8pckQc-UN3X08ul5QX6zFd1QCE0
  wA"}
      ],
    "ContentMetaData":"ewogICJjdHkiOiAiYXBwbGljYXRpb24vZXhhbXBsZS1t
  YWlsIn0"},
  "MSkDFKdTvdaal2PaFglWqb_Dyhna-MFn8fXSyhvl5dXTBnhawvgY2CM6tPAS2oxf
  DKLqwiFkDlkI6k5d_v9_Uw"
  ]]]></artwork>
</figure>
<section title="Key Exchange" anchor="s-3_4_1">
<t>
The DARE key exchange is based on the JWE key exchange except that encryption modes are intentionally limited and the output of the key exchange is the DARE Master Key rather than the Content Encryption Key.</t>
<t>
A DARE Key Exchange MAY contain any number of Recipient entries, each providing a means of decrypting the Master Key using a different private key.</t>
<t>
If the Key Exchange mechanism supports message recovery, Direct Key Agreement is used, in all other cases, Key Wrapping is used.</t>
<t>
This approach allows envelopes with one intended recipient to be handled in the exact same fashion as envelopes with multiple recipients. While this does require an additional key wrapping operation, that could be avoided if an envelope has exactly one intended recipient, this is offset by the reduction in code complexity.</t>
<t>
If the key exchange algorithm does not support message recovery (e.g. Diffie Hellman and Elliptic Curve Diffie-Hellman), the HKDF Extract-and-Expand Key Derivation Function is used to derive a master key using the following info tag:</t>
<t><list style="hanging">
<t hangText="&quot;dare-master&quot; [64 61 72 65 2d 6d 61 73 74 65 72]">
Key derivation info field used when deriving a master key from the output of a key exchange.</t>
</list></t>
<t>
The master key length is the maximum of the key size of the encryption algorithm specified by the key exchange header, the key size of the MAC algorithm specified by the key exchange header (if used) and 256.</t>
</section>
<section title="Key Identifiers" anchor="s-3_4_2">
<t>
The JWE/JWS specifications define a kid field for use as a key identifier but not how the identifier itself is constructed. All DARE key identifiers are either UDF key fingerprints <xref target="draft-hallambaker-mesh-udf">
</xref>
 or Mesh/Recrypt Group Key Identifiers.</t>
<t>
A UDF fingerprint is formed as the digest of an IANA content type and the digested data. A UDF key fingerprint is formed with the content type application/pkix-keyinfo and the digested data is the ASN.1 DER encoded PKIX certificate keyInfo sequence for the corresponding public key.</t>
<t>
A Group Key Identifier has the form &lt;fingerprint&gt;@&lt;domain&gt;. Where &lt;fingerprint&gt; is a UDF key fingerprint and &lt;domain&gt; is the DNS address of a service that provides the encryption service to support decryption by group members.</t>
</section>
<section title="Salt Derivation" anchor="s-3_4_3">
<t>
A Master Salt is a sequence of 16 or more octets that is specified in the Salt field of the header.</t>
<t>
The Master Salt is used to derive salt values for the envelope payload and associated encoded data sequences as follows.</t>
<t><list style="hanging">
<t hangText="Payload">
Salt = Master Salt</t>
<t hangText="EDS">
Salt = Concatenate (Payload Salt Prefix,  Master Salt)</t>
</list></t>
<t>
Encoders SHOULD NOT generate salt values that exceed 1024 octets.</t>
<t>
The salt value is opaque to the DARE encoding but MAY be used to encode application specific semantics including:</t>
<t><list style="symbols">
<t>
Frame number to allow reassembly of a data sequence split over a sequence of envelopes which may be delivered out of order.</t>
<t>
Transmit the Master Key in the manner of a Kerberos ticket.</t>
<t>
Identify the Master Key under which the Enhanced Data Sequence was generated.</t>
<t>
Enable access to the plaintext to be eliminated by erasure of the encryption key.</t>
</list></t>
<t>
For data erasure to be effective, the salt MUST be constructed so that the difficulty of recovering the key is sufficiently high that it is infeasible. For most purposes, a salt with 128 bits of appropriately random data is sufficient.</t>
</section>
<section title="Key Derivation" anchor="s-3_4_4">
<t>
Encryption and/or authentication keys are derived from the Master Key using a Extract-and-Expand Key Derivation Function as follows:</t>
<t><list style="numbers">
<t>
The Master Key and salt value are used to extract the PRK (pseudorandom key)</t>
<t>
The PRK is used to derive the algorithm keys using the application specific information input for that key type.</t>
</list></t>
<t>
The application specific information inputs are:</t>
<t><list style="hanging">
<t hangText="&quot;dare-encrypt&quot; [64 61 72 65 2d 65 6e 63 72 79 70 74]">
To generate an encryption or encryption with authentication key.</t>
<t hangText="&quot;dare-iv&quot; [64 61 72 65 2d 65 6e 63 72 79 70 74]">
To generate an initialization vector.</t>
<t hangText="&quot;dare-mac&quot; [dare-mac]">
To generate a Message Authentication Code key.</t>
</list></t>
</section>
</section>
<section title="Signature" anchor="s-3_5">
<t>
While encryption and integrity enhancements can be applied to any part of a DARE Envelope, signatures are only applied to payload digest values calculated over one or more envelope payloads. </t>
<t>
The payload digest value for an envelope is calculated over the binary payload data. That is, after any encryption enhancement has been applied but before the envelope encoding is applied. This allows envelopes to be converted from one encoding to another without affecting signature verification. </t>
<t><list style="hanging">
<t hangText="Single Payload">
The signed value is the payload digest of the envelope payload.</t>
<t hangText="Multiple Payload.">
The signed value is the root of a Merkle Tree in which the payload digest of the envelope is one of the leaves.</t>
</list></t>
<t>
Verification of a multiple payload signature naturally requires the additional digest values required to construct the Merkle Tree. These are provided in the Trailer in a format that permits multiple signers to reference the same tree data.</t>
</section>
<section title="Algorithms" anchor="s-3_6">
<section title="Field: kwd" anchor="s-3_6_1">
<t>
The key wrapping and derivation algorithms.</t>
<t>
Since the means of public key exchange is determined by the key identifier of the recipient key, it is only necessary to specify the algorithms used for key wrapping and derivation.</t>
<t>
The default (and so far only) algorithm is kwd-aes-sha2-256-256.</t>
<t>
Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm <xref target="RFC3394">
</xref>
 is used to wrap the Master Exchange Key. AES 256 is used.</t>
<t>
HMAC-based Extract-and-Expand Key Derivation Function <xref target="RFC5869">
</xref>
 is used for key derivation. SHA-2-256 is used for the hash function.</t>
</section>
</section>
</section>
<section title="DARE Container Architecture" anchor="s-4">
<section title="Container Navigation" anchor="s-4_1">
<t>
Three means of locating frames in a container are supported:</t>
<t><list style="hanging">
<t hangText="Sequential">
Access frames sequentially starting from the start or the end of the container.</t>
<t hangText="Binary search">
Access any container frame by frame number in O(log_2(n)) time by means of a binary tree constructed while the container is written.</t>
<t hangText="Index">
Access and container frame by frame number or by key by means of an index record.</t>
</list></t>
<t>
All DARE Containers support sequential access. Only tree and Merkle tree containers support binary search access. An index frame MAY be written appended to any container and provides O(1) access to any frame listed in the index.</t>
<t>
Two modes of compilation are considered:</t>
<t><list style="hanging">
<t hangText="Monolithic">
Frames are added to the container in a single operation, e.g. file archives, </t>
<t hangText="Incremental">
Additional frames are written to the container at various intervals after it was originally created, e.g. server logs, message spools.</t>
</list></t>
<t>
In the monolithic mode, navigation requirements are best met by writing an index frame to the end of the container when it is complete. It is not necessary to construct a binary search tree unless a Merkle tree integrity check is required.</t>
<t>
In the incremental mode, Binary search provides an efficient means of locating frames by frame number but not by key. Writing a complete index to the container every m write operations provides O(m) search access but requires O(n^2) storage.</t>
<t>
Use of partial indexes provides a better compromise between speed and efficiency. A partial index is written out every m frames where m is a power of two. A complete index is written every time a binary tree apex record is written. This approach provides for O(log_2(n)) search with incremental compilation with approximately double the overhead of the monolithic case.</t>
<section title="Tree" anchor="s-4_1_1">
<t>
Binary search is supported by means of the TreePosition parameter specified in the FrameHeader. This parameter specifies the value of the immediately preceding apex.</t>
<t>
Calculation of the immediately preceding apex is most easily described by representing the array index in binary with base of 1 (rather than 0). An array index that is a power of 2 (2, 4, 8, 16, etc.) will be the apex of a complete tree. Every other array index has the value of the sum of a set of powers of 2 and the immediately preceding apex will be the value of the next smallest power of 2 in the sum.</t>
<t>
For example, to find the immediately preceding apex for frame 5, we add 1 to get 6. 6 = 4 + 2, so we ignore the 2 and the preceding frame is 4.</t>
<t>
The values of Tree Position are shown for the first 8 frames in figure xx below:</t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
Merkle Tree Integrity check</postamble>
</figure>
<t>
An algorithm for efficiently calculating the immediately preceding apex is provided in Appendix C.</t>
</section>
<section title="Position Index" anchor="s-4_1_2">
<t>
Contains a table of frame number, position pairs pointing to prior locations in the file.</t>
</section>
<section title="Metadata Index" anchor="s-4_1_3">
<t>
Contains a list of IndexMeta entries. Each entry contains a metadata description and a list of frame indexes (not positions) of frames that match the description.</t>
</section>
</section>
<section title="Integrity Mechanisms" anchor="s-4_2">
<t>
Frame sequences in a DARE container MAY be protected against a frame insertion attack by means of a digest chain, a binary Merkle tree or both.</t>
<section title="Digest Chain calculation" anchor="s-4_2_1">
<t>
A digest chain is simple to implement but can only be verified if the full chain of values is known. Appending a frame to the chain has O(1) complexity but verification has O(n) complexity:</t>
<figure>
<preamble>
[[This figure is not viewable in this format. The figure is available at <eref target="http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html">http://mathmesh.com/Documents/draft-hallambaker-mesh-dare.html</eref>.]]</preamble>
<artwork>
</artwork>
<postamble>
Hash chain integrity check</postamble>
</figure>
<t>
The value of the chain digest for the first frame (frame 0) is H(H(null)+H(Payload_0)), where null is a zero length octet sequence and payloadn is the sequence of payload data bytes for frame n</t>
<t>
The value of the chain digest for frame n is H(H(Payload_n-1 +H(Payloadn)), where A+B stands for concatenation of the byte sequences A and B.</t>
</section>
<section title="Binary Merkle tree calculation" anchor="s-4_2_2">
<t>
The tree index mechanism describe earlier may be used to implement a binary Merkle tree. The value TreeDigest specifies the apex value of the tree for that node.</t>
<t>
Appending a frame to the chain has O(log_2 (n)) complexity provided that the container format supports at least the binary tree index. Verifying a chain has O(log_2 (n)) complexity, provided that the set of necessary digest inputs is known.</t>
<t>
To calculate the value of the tree digest for a node, we first calculate the values of all the sub trees that have their apex at that node and then calculate the digest of that value and the immediately preceding local apex.</t>
</section>
<section title="Signature" anchor="s-4_2_3">
<t>
Payload data MAY be signed using a JWS <xref target="RFC7515">
</xref>
 as applied in the Envelope.</t>
<t>
Signatures are specified by the Signatures parameter in the content header. The data that the signature is calculated over is defined by the typ parameter of the Signature as follows.</t>
<t><list style="hanging">
<t hangText="Payload">
The value of the PayloadDigest parameter</t>
<t hangText="Chain">
The value of the ChainDigest parameter</t>
<t hangText="Tree">
The value of the TreeDigestFinal parameter</t>
</list></t>
<t>
If the typ parameter is absent, the value Payload is implied.</t>
<t>
A frame MAY contain multiple signatures created with the same signing key and different typ values.</t>
<t>
The use of signatures over chain and tree digest values permit multiple frames to be validated using a single signature verification operation.</t>
</section>
</section>
</section>
<section title="DARE Schema" anchor="s-5">
<t>
A DARE Envelope consists of a Header, an Enhanced Data Sequence (EDS) and  an optional trailer. This section describes the JSON data fields used to  construct headers, trailers and complete messages. </t>
<t>
Wherever possible, fields from JWE, JWS and JWK have been used. In these cases, the fields have the exact same semantics. Note however that the classes in  which these fields are presented have different structure and nesting. </t>
<section title="Message Classes" anchor="s-5_1">
<t>
A DARE Message contains a single DAREMessageSequence in either the JSON or  Compact serialization as directed by the protocol in which it is applied. </t>
<section title="Structure: DareEnvelopeSequence" anchor="s-5_1_1">
<t>
A DARE Message containing Header, EDS and Trailer in JSON object encoding. Since a DAREMessage is almost invariably presented in JSON sequence or compact encoding, use of the DAREMessage subclass is preferred. </t>
<t>
Although a DARE Message is functionally an object, it is serialized as  an ordered sequence. This ensures that the message header field will always precede the body in a serialization, this allowing processing of the header information to be performed before the entire body has been received. </t>
<t><list style="hanging">
<t hangText="Header: DareHeader (Optional)">
The message header. May specify the key exchange data, pre-signature  or signature data, cloaked headers and/or encrypted data sequences. </t>
<t hangText="Body: Binary (Optional)">
The message body </t>
<t hangText="Trailer: DareTrailer (Optional)">
The message trailer. If present, this contains the signature.  </t>
</list></t>
</section>
</section>
<section title="Header and Trailer Classes" anchor="s-5_2">
<t>
A DARE Message sequence MUST contain a (possibly empty) DAREHeader and MAY contain a DARETrailer.  </t>
<section title="Structure: DareTrailer" anchor="s-5_2_1">
<t>
A DARE Message Trailer </t>
<t><list style="hanging">
<t hangText="Signatures: DareSignature [0..Many]">
A list of signatures. A message trailer MUST NOT contain a signatures field if the header contains  a signatures field. </t>
<t hangText="SignedData: Binary (Optional)">
Contains a DAREHeader object  </t>
<t hangText="PayloadDigest: Binary (Optional)">
If present, contains the digest of the Payload. </t>
<t hangText="ChainDigest: Binary (Optional)">
If present, contains the digest of the PayloadDigest values of this frame and the frame immediately preceding. </t>
<t hangText="TreeDigest: Binary (Optional)">
If present, contains the Binary Merkle Tree digest value.  </t>
</list></t>
</section>
<section title="Structure: DareHeader" anchor="s-5_2_2">
<t><list style="hanging">
<t hangText="Inherits: DareTrailer"></t>
</list></t>
<t>
A DARE Message Header. Since any field that is present in a trailer MAY be  placed in a header instead, the message header inherits from the trailer. </t>
<t><list style="hanging">
<t hangText="EnvelopeID: String (Optional)">
Unique identifier </t>
<t hangText="EncryptionAlgorithm: String (Optional)">
The encryption algorithm as specified in JWE </t>
<t hangText="DigestAlgorithm: String (Optional)">
Digest Algorithm. If specified, tells decoder that the digest algorithm is used to construct a signature over the message payload. </t>
<t hangText="Salt: Binary (Optional)">
Salt value used to derrive cryptographic parameters for the content data. </t>
<t hangText="Malt: Binary (Optional)">
Hash of the Salt value used to derrive cryptographic parameters for the content data. This field SHOULD NOT be present if the Salt field is present. It is used to allow the salt value to be erased (thus rendering the payload content irrecoverable) without affecting the ability to calculate the payload digest value. </t>
<t hangText="Cloaked: Binary (Optional)">
If present in a header or trailer, specifies an encrypted data block  containing additional header fields whose values override those specified  in the message and context headers. </t>
<t>
When specified in a header, a cloaked field MAY be used to conceal metadata  (content type, compression) and/or to specify an additional layer of key exchange.  That applies to both the Message body and to headers specified within the cloaked  header. </t>
<t>
Processing of cloaked data is described in... </t>
<t hangText="EDSS: Binary [0..Many]">
If present, the Annotations field contains a sequence of Encrypted Data  Segments encrypted under the message Master Key. The interpretation of these fields  is application specific. </t>
<t hangText="Signers: DareSigner [0..Many]">
A list of 'presignature' </t>
<t hangText="Recipients: DareRecipient [0..Many]">
A list of recipient key exchange information blocks. </t>
<t hangText="ContentMetaData: Binary (Optional)">
If present contains a JSON encoded ContentInfo structure which specifies plaintext content metadata and forms one of the inputs to the envelope digest value. </t>
<t hangText="ContainerInfo: ContainerInfo (Optional)">
Information that describes container information </t>
<t hangText="ContainerIndex: ContainerIndex (Optional)">
An index of records in the current container up to but not including this one.  </t>
</list></t>
</section>
<section title="Structure: ContentMeta" anchor="s-5_2_3">
<t><list style="hanging">
<t hangText="UniqueID: String (Optional)">
Unique object identifier </t>
<t hangText="Labels: String [0..Many]">
List of labels that are applied to the payload of the frame. </t>
<t hangText="KeyValues: KeyValue [0..Many]">
List of key/value pairs describing the payload of the frame. </t>
<t hangText="MessageType: String (Optional)">
The mesh message type </t>
<t hangText="ContentType: String (Optional)">
The content type field as specified in JWE </t>
<t hangText="Paths: String [0..Many]">
List of filename paths for the payload of the frame. </t>
<t hangText="Filename: String (Optional)">
The original filename under which the data was stored. </t>
<t hangText="Event: String (Optional)">
Operation on the header </t>
<t hangText="Created: DateTime (Optional)">
Initial creation date. </t>
<t hangText="Modified: DateTime (Optional)">
Date of last modification. </t>
<t hangText="First: Integer (Optional)">
Frame number of the first object instance value. </t>
<t hangText="Previous: Integer (Optional)">
Frame number of the immediately prior object instance value	  </t>
</list></t>
</section>
</section>
<section title="Cryptographic Data" anchor="s-5_3">
<t>
DARE Message uses the same fields as JWE and JWS but with different structure. In particular, DARE messages MAY have multiple recipients and multiple signers. </t>
<section title="Structure: DareSigner" anchor="s-5_3_1">
<t>
The signature value </t>
<t><list style="hanging">
<t hangText="Dig: String (Optional)">
Digest algorithm hint. Specifying the digest algorithm to be applied to the message body allows the body to be processed in streaming mode. </t>
<t hangText="Alg: String (Optional)">
Key exchange algorithm </t>
<t hangText="KeyIdentifier: String (Optional)">
Key identifier of the signature key. </t>
<t hangText="Certificate: X509Certificate (Optional)">
PKIX certificate of signer. </t>
<t hangText="Path: X509Certificate (Optional)">
PKIX certificates that establish a trust path for the signer.  </t>
</list></t>
</section>
<section title="Structure: X509Certificate" anchor="s-5_3_2">
<t><list style="hanging">
<t hangText="X5u: String (Optional)">
URL identifying an X.509 public key certificate </t>
<t hangText="X5: Binary (Optional)">
An X.509 public key certificate  </t>
</list></t>
</section>
<section title="Structure: DareSignature" anchor="s-5_3_3">
<t><list style="hanging">
<t hangText="Inherits: DareSigner"></t>
</list></t>
<t>
The signature value </t>
<t><list style="hanging">
<t hangText="Manifest: Binary (Optional)">
The data description that was signed. </t>
<t hangText="SignatureValue: Binary (Optional)">
The signature value as an Enhanced Data Sequence under the message Master Key. </t>
<t hangText="WitnessValue: Binary (Optional)">
The signature witness value used on an encrypted message to demonstrate that  the signature was authorized by a party with actual knowledge of the encryption  key used to encrypt the message.  </t>
</list></t>
</section>
<section title="Structure: DareRecipient" anchor="s-5_3_4">
<t>
Recipient information </t>
<t><list style="hanging">
<t hangText="KeyIdentifier: String (Optional)">
Key identifier for the encryption key. </t>
<t>
The Key identifier MUST be either a UDF fingerprint of a key or a Group Key Identifier </t>
<t hangText="KeyWrapDerivation: String (Optional)">
The key wrapping and derivation algorithms. </t>
<t hangText="WrappedMasterKey: Binary (Optional)">
The wrapped master key. The master key is encrypted under the result of the key exchange. </t>
<t hangText="RecipientKeyData: String (Optional)">
The per-recipient key exchange data.  </t>
</list></t>
</section>
</section>
</section>
<section title="DARE Container Schema" anchor="s-6">
<t>
TBS stuff </t>
<section title="Container Headers" anchor="s-6_1">
<t>
TBS stuff </t>
<section title="Structure: ContainerInfo" anchor="s-6_1_1">
<t><list style="hanging">
<t hangText="DataEncoding: String (Optional)">
Specifies the data encoding for the header section of for the following frames. This value is ONLY valid in Frame 0 which MUST have a header encoded in JSON. Information that describes container information </t>
<t hangText="Index: Integer (Optional)">
The record index within the file. This MUST be unique and  satisfy any additional requirements determined by the ContainerType. </t>
<t hangText="ContainerType: String (Optional)">
Specifies the container type for the following records. </t>
<t hangText="IsMeta: Boolean (Optional)">
If true, the current frame is a meta frame and does not contain a payload. </t>
<t>
Note: Meta frames MAY be present in any container. Applications MUST accept containers that contain meta frames at any position in the file. Applications MUST NOT interpret a meta frame as a data frame with an enpty payload. </t>
<t hangText="Default: Boolean (Optional)">
If set true in a persistent container, specifies that this record contains the default object for the container. </t>
<t hangText="TreePosition: Integer (Optional)">
Position of the frame containing the apex of the preceding sub-tree. </t>
<t hangText="IndexPosition: Integer (Optional)">
Specifies the position in the file at which the last index entry is to be found </t>
<t hangText="ExchangePosition: Integer (Optional)">
Specifies the position in the file at which the key exchange data is to be found  </t>
</list></t>
</section>
</section>
<section title="Index Structures" anchor="s-6_2">
<t>
TBS stuff </t>
<section title="Structure: ContainerIndex" anchor="s-6_2_1">
<t>
A container index </t>
<t><list style="hanging">
<t hangText="Full: Boolean (Optional)">
If true, the index is complete and contains position entries for all the  frames in the file. If absent or false, the index is incremental and only contains position entries for records added since the last  frame containing a ContainerIndex. </t>
<t hangText="Positions: IndexPosition [0..Many]">
List of container position entries </t>
<t hangText="Metas: IndexMeta [0..Many]">
List of container position entries  </t>
</list></t>
</section>
<section title="Structure: IndexPosition" anchor="s-6_2_2">
<t>
Specifies the position in a file at which a specified record index is found </t>
<t><list style="hanging">
<t hangText="Index: Integer (Optional)">
The record index within the file. </t>
<t hangText="Position: Integer (Optional)">
The record position within the file relative to the index base.  </t>
</list></t>
</section>
<section title="Structure: KeyValue" anchor="s-6_2_3">
<t>
Specifies a key/value entry </t>
<t><list style="hanging">
<t hangText="Key: String (Optional)">
The key </t>
<t hangText="Value: String (Optional)">
The value corresponding to the key  </t>
</list></t>
</section>
<section title="Structure: IndexMeta" anchor="s-6_2_4">
<t>
Specifies the list of index entries at which a record with the specified metadata occurrs. </t>
<t><list style="hanging">
<t hangText="Index: Integer [0..Many]">
List of record indicies within the file where frames matching the specified  criteria are found. </t>
<t hangText="ContentType: String (Optional)">
Content type parameter </t>
<t hangText="Paths: String [0..Many]">
List of filename paths for the current frame. </t>
<t hangText="Labels: String [0..Many]">
List of labels that are applied to the current frame.  </t>
</list></t>
</section>
</section>
</section>
<section title="Dare Container Applications" anchor="s-7">
<t>
DARE Containers are used to implement two forms of persistence store to support Mesh operations:</t>
<t><list style="hanging">
<t hangText="Catalogs">
A set of related items which MAY be added, modified or deleted at any time.</t>
<t hangText="Spools">
A list of related items whose status MAY be changed at any time but which are immutable once added.</t>
</list></t>
<t>
Since DARE Containers are an append only log format, entries can only be modified or deleted by adding items to the log to change the status of previous entries. It is always possible to undo any operation on a catalog or spool unless the underlying container is purged or the individual entries modified.</t>
<section title="Catalog" anchor="s-7_1">
<t>
Catalogs contain a set of entries, each of which is distinguished by a unique identifier.</t>
<t>
Three operations are supported:</t>
<t><list style="hanging">
<t hangText="Add">
Addition of the entry to the catalog</t>
<t hangText="Update">
Modification of the data associated with the entry excluding the identifier</t>
<t hangText="Delete">
Removal of the entry from the catalog</t>
</list></t>
<t>
The set of valid state transitions is defined by the Finite State machine:</t>
<t>
(Add-Update*-Delete)*</t>
<t>
Catalogs are used to represent sets of persistent objects associated with a Mesh Service Account. The user's set of contacts for example. Each contact entry may be modified many times over time but refers to the same subject for its entire lifetime.</t>
<t>
SchemaCatalog </t>
</section>
<section title="Spool" anchor="s-7_2">
<t>
Spools contain lists of entries, each of which is distinguished by a unique identifier.</t>
<t>
Four operations are supported:</t>
<t><list style="hanging">
<t hangText="Post">
Addition of the entry to the spool</t>
<t hangText="Processed">
Marks the entry as having been processed.</t>
<t hangText="Unprocessed">
Returns the entry to the unread state.</t>
<t hangText="Delete">
Mark the entry as deleted allowing recovery of associated storage in a subsequent purge operation.</t>
</list></t>
<t>
The set of valid state transitions is defined by the Finite State machine:</t>
<t>
Post-(Processed| Unprocessed| Delete *)</t>
<t>
Spools are used to represent time sequence ordered entries such as lists of messages being sent or received, task queues and transaction logs.</t>
<t>
SchemaCatalog </t>
</section>
<section title="Archive" anchor="s-7_3">
<t>
A DARE Archive is a DARE Container whose entries contain files. This affords the same functionality as a traditional ZIP or tar archive but with the added cryptographic capabilities provided by the DARE format.</t>
</section>
</section>
<section title="Future Work" anchor="s-8">
<t>
The current specification describes an approach in which containers are written according to a strict append-only policy. Greater flexibility may be achieved by loosening this requirement allowing record(s) at the end of the container to be overwritten.</t>
<section title="Terminal integrity check" anchor="s-8_1">
<t>
A major concern when operating a critical service is the possibility of a hardware or power failure occurring during a write operation causing the file update to be incomplete. While most modern operating systems have effective mechanisms in place to prevent corruption of the file system itself in such circumstances, this does not provide sufficient protection at the application level.</t>
<t>
Appending a null record containing a container-specific magic number provides an effective means of detecting this circumstance that can be quickly verified.</t>
<t>
If a container specifies a terminal integrity check value in the header of frame zero, the container is considered to be in an incomplete write state if the final frame is not a null record specifying the magic number.</t>
<t>
When appending new records to such containers, the old terminal integrity check record is overwritten by the data being added and a new integrity check record appended to the end.</t>
</section>
<section title="Terminal index record" anchor="s-8_2">
<t>
A writer can maintain a complete (or partial) index of the container in its final record without additional space overhead by overwriting the prior index on each update.</t>
</section>
<section title="Deferred indexing" anchor="s-8_3">
<t>
The task of updating terminal indexes may be deferred to a time when the machine is not busy. This improves responsiveness and may avoid the need to re-index containers receiving a sequence of updates.</t>
<t>
This approach may be supported by appending new entries to the end of the container in the usual fashion and maintaining a record of containers to be updated as a separate task.</t>
<t>
When updating the index on a container that has been updated in this fashion, the writer must ensure that no data is lost even if the process is interrupted. The use of guard records and other precautions against loss of state is advised. </t>
</section>
</section>
<section title="Security Considerations" anchor="s-9">
<t>
This section describes security considerations arising from the use of DARE in general applications.</t>
<t>
Additional security considerations for use of DARE in Mesh services and applications are described in the Mesh Security Considerations guide <xref target="draft-hallambaker-mesh-security">
</xref>
.</t>
<section title="Encryption/Signature nesting" anchor="s-9_1">
</section>
<section title="Side channel" anchor="s-9_2">
</section>
<section title="Salt reuse" anchor="s-9_3">
</section>
</section>
<section title="IANA Considerations" anchor="s-10">
</section>
<section title="Acknowledgements" anchor="s-11">
<t>
A list of people who have contributed to the design of the Mesh is presented in <xref target="draft-hallambaker-mesh-architecture">
</xref>
.</t>
<t>
The name Data At Rest Encryption was proposed by Melhi Abdulhayo?lu.</t>
</section>
<section title="Appendix A: DARE Envelope Examples and Test Vectors" anchor="s-12">
</section>
<section title="Test Examples" anchor="s-13">
<t>
In the following examples, Alice's encryption private key parameters are: </t>
<figure anchor="s-13-2" suppress-title="true">
<artwork>
<![CDATA[{
  "PrivateKeyECDH":{
    "crv":"Ed25519",
    "Private":"w5Mb-JUeh0POjYRZ4N_TVv_1jQ1_l1-QyHQM0lfulE8"}}]]></artwork>
</figure>
<t>
Alice's signature private key parameters are: </t>
<figure anchor="s-13-4" suppress-title="true">
<artwork>
<![CDATA[{
  "PrivateKeyECDH":{
    "crv":"Ed25519",
    "Private":"z-s7U8acjiWdR02gtwIjSz3LVRNOi38GT61pHjI5nNo"}}]]></artwork>
</figure>
<t>
The body of the test message is the UTF8 representation of the following string: </t>
<figure anchor="s-13-6" suppress-title="true">
<artwork>
<![CDATA["This is a test long enough to require multiple blocks"]]></artwork>
</figure>
<t>
The EDS sequences, are the UTF8 representation of the following strings: </t>
<figure anchor="s-13-8" suppress-title="true">
<artwork>
<![CDATA["Subject: Message metadata should be encrypted"
"2018-02-01"]]></artwork>
</figure>
<section title="Plaintext Message" anchor="s-13_1">
<t>
A plaintext message without associated EDS sequences is an empty header followed by the message body: </t>
<figure anchor="s-13_1-2" suppress-title="true">
<artwork>
<![CDATA[{
  "DareEnvelope":[{},
    "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
  BibG9ja3M"
    ]}]]></artwork>
</figure>
</section>
<section title="Plaintext Message with EDS" anchor="s-13_2">
<t>
If a plaintext message contains EDS sequences, these are also in plaintext: </t>
<figure anchor="s-13_2-2" suppress-title="true">
<artwork>
<![CDATA[{
  "DareEnvelope":[{
      "Annotations":["iAEBiC1TdWJqZWN0OiBNZXNzYWdlIG1ldGFkYXRhIHNob3
  VsZCBiZSBlbmNyeXB0ZWSIAA",
        "iAECiAoyMDE4LTAyLTAxiAA"
        ]},
    "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
  BibG9ja3M"
    ]}]]></artwork>
</figure>
</section>
<section title="Encrypted Message" anchor="s-13_3">
<t>
The creator generates a master session key: </t>
<figure anchor="s-13_3-2" suppress-title="true">
<artwork>
<![CDATA[
  72 02 B0 02  E1 8D 16 3F  30 3F 3B E2  79 0C E8 A0
  36 85 92 B3  6B 50 4E 44  73 74 D4 5E  D9 B4 54 2D]]></artwork>
</figure>
<t>
For each recipient of the message: </t>
<t>
The creator generates an ephemeral key: </t>
<figure anchor="s-13_3-5" suppress-title="true">
<artwork>
<![CDATA[{
  "PrivateKeyECDH":{
    "crv":"Ed25519",
    "Private":"lpxvx4a1YZsUS3PDAWMGV_SeNQKV4BveTNCBHhwoBVM"}}]]></artwork>
</figure>
<t>
The key agreement value is calculated: </t>
<figure anchor="s-13_3-7" suppress-title="true">
<artwork>
<![CDATA[
  F9 B1 C6 A6  47 E7 C5 D1  BB C6 A3 56  1F 9D 11 26
  2C 42 47 95  54 41 EA F3  82 E0 6B 5F  EF 3A BD 5B]]></artwork>
</figure>
<t>
The key agreement value is used as the input to a HKDF key derivation function with the info parameter  master to create the key used to wrap the master key: </t>
<figure anchor="s-13_3-9" suppress-title="true">
<artwork>
<![CDATA[
  4D 17 AD D7  B1 2D 27 92  D4 D8 3D A7  84 23 87 E8
  2B E8 34 13  94 FF 89 6B  FE 16 C6 DF  4F BE 47 A8]]></artwork>
</figure>
<t>
The wrapped master key is: </t>
<figure anchor="s-13_3-11" suppress-title="true">
<artwork>
<![CDATA[
  A0 0F B5 A4  DA 0D A8 45  C6 2A E5 8F  EE 5E 2E C1
  D7 6A 4D A2  C8 A6 39 40  A4 E8 4B DF  B4 C2 B8 BA
  65 82 92 CF  6B F1 9A 81]]></artwork>
</figure>
<t>
This information is used to calculate the Recipient information shown in the example below. </t>
<t>
To encrypt a message, we first generate a unique salt value: </t>
<figure anchor="s-13_3-14" suppress-title="true">
<artwork>
<![CDATA[
  89 F1 C8 7D  A6 DF 18 97  5B CC 8C FE  A8 78 94 B9]]></artwork>
</figure>
<t>
The salt value and master key are used to generate the payload encryption key: </t>
<figure anchor="s-13_3-16" suppress-title="true">
<artwork>
<![CDATA[
  F6 B0 8C EA  0B C3 DC FD  58 F3 88 DC  A4 0C F9 50
  D6 43 5A 7D  0B BB 41 C2  1B 61 2E 7C  41 27 37 75]]></artwork>
</figure>
<t>
Since AES is a block cipher, we also require an initializarion vector: </t>
<figure anchor="s-13_3-18" suppress-title="true">
<artwork>
<![CDATA[
  73 91 C0 8B  A5 0E C5 3C  33 F7 7F 4C  6E 8F 8C B2]]></artwork>
</figure>
<t>
The output sequence is the encrypted bytes: </t>
<figure anchor="s-13_3-20" suppress-title="true">
<artwork>
<![CDATA[
  92 B5 F7 A8  53 B8 67 2D  F3 48 A3 F3  8A 97 24 3B
  99 A4 C5 07  F2 6F 64 15  59 9A E9 27  99 4D 1E 98
  6F 2D 92 73  39 CA D5 8F  7C 9E 15 DD  F0 D0 ED 9A
  34 DF A2 1B  04 45 B2 C8  BC B8 CF A9  4C 48 02 FB]]></artwork>
</figure>
<t>
Since the message is not signed, there is no need for a trailer. The completed message is: </t>
<figure anchor="s-13_3-22" suppress-title="true">
<artwork>
<![CDATA[{
  "DareEnvelope":[{
      "enc":"A256CBC",
      "Salt":"ifHIfabfGJdbzIz-qHiUuQ",
      "recipients":[{
          "kid":"MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
          "epk":{
            "PublicKeyECDH":{
              "crv":"Ed25519",
              "Public":"uSIwbaeQq9bTSjRATO4su0ZuhU19xH9SYWm4a8VR5Ik"}},
          "wmk":"oA-1pNoNqEXGKuWP7l4uwddqTaLIpjlApOhL37TCuLplgpLPa_
  GagQ"}
        ]},
    "krX3qFO4Zy3zSKPzipckO5mkxQfyb2QVWZrpJ5lNHphvLZJzOcrVj3yeFd3w0O
  2aNN-iGwRFssi8uM-pTEgC-w"
    ]}]]></artwork>
</figure>
</section>
<section title="Signed Message" anchor="s-13_4">
<t>
Signed messages specify the digest algorithm to be used in the header and the signature value in the trailer. Note that the digest algorithm is not optional since it serves as notice that a decoder should digest the payload value  to enable signature verification. </t>
<figure anchor="s-13_4-2" suppress-title="true">
<artwork>
<![CDATA[{
  "DareEnvelope":[{
      "dig":"S512"},
    "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
  BibG9ja3M",
    {
      "signatures":[{
          "alg":"S512",
          "kid":"MA7E-V5IH-VTH6-PB6K-DY2E-HMA4-TJ4S",
          "signature":"6n3Vfc0fl7K6X4kMzlBM06_VzoOuMZU1orgt36c2KQSk
  EYiF8_UYI8SezrAyyO5e5xOuwAgXjWHxJFoHu4JBAw"}
        ],
      "PayloadDigest":"raim8SV5adPbWWn8FMM4mrRAQCO9A2jZ0NZAnFXWlG0x
  F6sWGJbnKSdtIJMmMU_hjarlIPEoY3vy9UdVlH5KAg"}
    ]}]]></artwork>
</figure>
</section>
<section title="Signed and Encrypted Message" anchor="s-13_5">
<t>
A signed and encrypted message is encrypted and then signed. The signer proves knowledge of the payload plaintext by providing the plaintext witness value. </t>
<figure anchor="s-13_5-2" suppress-title="true">
<artwork>
<![CDATA[{
  "DareEnvelope":[{
      "enc":"A256CBC",
      "dig":"S512",
      "Salt":"MZHWMXCJa0DJO14W1ucl8g",
      "recipients":[{
          "kid":"MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
          "epk":{
            "PublicKeyECDH":{
              "crv":"Ed25519",
              "Public":"9DGSgodrNodrZVKDtaBG6B4_CO0jZH9uqkK2flKisls"}},
          "wmk":"9GzV9CeA0S_tOP7W3Yx_-rdfK41znQBCfm_fO3RaQOHar3XjM2
  h8KQ"}
        ]},
    "srOi9TEXlkwSG0nBzOuxBZJB33BH3emy251PHJ06AsuV-Bjejh0CO3osASb9xW
  IKmCtuY7zk66F0TA6bjWg1CQ",
    {
      "signatures":[{
          "alg":"S512",
          "kid":"MA7E-V5IH-VTH6-PB6K-DY2E-HMA4-TJ4S",
          "signature":"FVXeeCOwhqA2EJx4Pa8hSDKnvy7af2lz_0YPH6yfBgJo
  akdOXdjq8obCPn24obO14vBwn5pQeJapSNMRERS-Dw",
          "witness":"ZWg9RgA6HR1s1wTnDbqcI9gY3DFNS-CV1ol83D3nOLU"}
        ],
      "PayloadDigest":"elW1N5xHbFXSmBqxP5dqy5_b-0BH_Z6WmLr2M1wC5hrh
  duYTLyKwOIKC2VBHaLwLPsSlMeHODS0bxiR2j5-JoQ"}
    ]}]]></artwork>
</figure>
</section>
</section>
<section title="Appendix B: DARE Container Examples and Test Vectors" anchor="s-14">
<t>
The data payloads in all the following examples are identical, only the authentication and/or encryption is different.  </t>
<t><list style="symbols">
<t>
 Frame 1..n consists of 300 bytes being the byte sequence 00, 01, 02, etc.  repeating after 256 bytes. </t>
</list></t>
<t>
For conciseness, the raw data format is omitted for examples after the first, except where the data payload has been transformed, (i.e. encrypted). </t>
<section title="Simple container" anchor="s-14_1">
<t>
the following example shows a simple container with first frame and a single data frame: </t>
<figure anchor="s-14_1-2" suppress-title="true">
<artwork>
<![CDATA[f4 82 
f0 7c 
f0 00 
f0 00 
82 f4 
f5 01 74 
f0 43 
f1 01 2c 
74 01 f5 ]]></artwork>
</figure>
<t>
Since there is no integrity check, there is no need for trailer entries. The header values are: </t>
<t>
Frame 0 </t>
<figure anchor="s-14_1-5" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "List"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_1-7" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1}}

[Empty trailer]]]></artwork>
</figure>
</section>
<section title="Payload and chain digests" anchor="s-14_2">
<t>
The following example shows a chain container with a first frame and three  data frames. The headers of these frames is the same as before but the frames now have trailers specifying the PayloadDigest and ChainDigest values: </t>
<t>
Frame 0 </t>
<figure anchor="s-14_2-3" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "Chain"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_2-5" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
  Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 2 </t>
<figure anchor="s-14_2-7" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 2}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
  Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 3 </t>
<figure anchor="s-14_2-9" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 3}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
  Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
</section>
<section title="Merkle Tree" anchor="s-14_3">
<t>
The following example shows a chain container with a first frame and six  data frames. The trailers now contain the TreePosition and TreeDigest values: </t>
<t>
Frame 0 </t>
<figure anchor="s-14_3-3" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "Merkle"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_3-5" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1,
    "TreePosition": 0}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
  z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 2 </t>
<figure anchor="s-14_3-7" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 2,
    "TreePosition": 360}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "7fHmkEIsPkN6sDYAOLvpIJn5Dg3PxDDAaq-ll2kh8722kokk
  FnZQcYtjuVC71aHNXI18q-lPnfRkmwryG-bhqQ"}]]></artwork>
</figure>
<t>
Frame 3 </t>
<figure anchor="s-14_3-9" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 3,
    "TreePosition": 360}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
  z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 4 </t>
<figure anchor="s-14_3-11" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 4,
    "TreePosition": 1612}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "vJ6ngNATvZcXSMALi5IUqzl1GBxBnTNVcC87VL_BhMRCbAvK
  Sj8gs0VFgxxLkZ2myrtaDIwhHoswiTiBMLNWug"}]]></artwork>
</figure>
<t>
Frame 5 </t>
<figure anchor="s-14_3-13" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 5,
    "TreePosition": 1612}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
  z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 6 </t>
<figure anchor="s-14_3-15" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 6,
    "TreePosition": 2867}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "WgHlz3EHczVPqgtpc39Arv7CFIsCbFVsk8wg0j2qLlEfur9S
  Z0mdr65Ka-HF0Qx8gg_DAoiJwUrwADDXyxVJOg"}]]></artwork>
</figure>
</section>
<section title="Signed container" anchor="s-14_4">
<t>
The following example shows a tree container with a signature in the final record. The signing key parameters are: </t>
<figure anchor="s-14_4-2" suppress-title="true">
<artwork>
<![CDATA[{
  "PrivateKeyECDH":{
    "crv":"Ed25519",
    "Private":"z-s7U8acjiWdR02gtwIjSz3LVRNOi38GT61pHjI5nNo"}}]]></artwork>
</figure>
<t>
The container headers and trailers are: </t>
<t>
Frame 0 </t>
<figure anchor="s-14_4-5" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "Merkle"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_4-7" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1,
    "TreePosition": 0}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
  z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}]]></artwork>
</figure>
<t>
Frame 2 </t>
<figure anchor="s-14_4-9" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 2,
    "TreePosition": 360}}

{
  "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
  lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
  "TreeDigest": "7fHmkEIsPkN6sDYAOLvpIJn5Dg3PxDDAaq-ll2kh8722kokk
  FnZQcYtjuVC71aHNXI18q-lPnfRkmwryG-bhqQ"}]]></artwork>
</figure>
</section>
<section title="Encrypted container" anchor="s-14_5">
<t>
The following example shows a container in which all the frame payloads are encrypted  under the same master secret established in a key agreement specified in the first frame. </t>
<t>
Frame 0 </t>
<figure anchor="s-14_5-3" suppress-title="true">
<artwork>
<![CDATA[{
  "enc": "A256CBC",
  "Salt": "XbIG_EpZWHTRdorffbqNHA",
  "recipients": [{
      "kid": "MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
      "epk": {
        "PublicKeyECDH": {
          "crv": "Ed25519",
          "Public": "_u8TpOcChwHUJa3NMt3CMeQnHLomPS6I-9HBk1tMZA8"}},
      "wmk": "L376haSjimKy1mmYnF8BoFOt1-H2hgtnGNclDz9BGZzhEoDDvQ5dPw"}],
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "List"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_5-5" suppress-title="true">
<artwork>
<![CDATA[{
  "enc": "A256CBC",
  "Salt": "ojzb__E2uG87qCyZ576mrg",
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 2 </t>
<figure anchor="s-14_5-7" suppress-title="true">
<artwork>
<![CDATA[{
  "enc": "A256CBC",
  "Salt": "Nx3K3IxWXtNL01VHmWiUBw",
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 2}}

[Empty trailer]]]></artwork>
</figure>
<t>
Here are the container bytes. Note that the content is now encrypted and has expanded by 25 bytes. These are the salt (16 bytes), the AES padding (4 bytes) and the  JSON-B framing (5 bytes). </t>
<figure anchor="s-14_5-9" suppress-title="true">
<artwork>
<![CDATA[f5 01 e5 
f1 01 ce 
f0 10 
f0 00 
e5 01 f5 
f5 01 b0 
f0 7b 
f1 01 30 
b0 01 f5 
f5 01 b0 
f0 7b 
f1 01 30 
b0 01 f5 

]]></artwork>
</figure>
<t>
The following example shows a container in which all the frame payloads are encrypted  under separate key agreements specified in the payload frames. </t>
<t>
Frame 0 </t>
<figure anchor="s-14_5-12" suppress-title="true">
<artwork>
<![CDATA[{
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "DataEncoding": "JSON",
    "Index": 0,
    "ContainerType": "List"}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 1 </t>
<figure anchor="s-14_5-14" suppress-title="true">
<artwork>
<![CDATA[{
  "enc": "A256CBC",
  "Salt": "YpxCFwgNYn0_HenUxMpEBg",
  "recipients": [{
      "kid": "MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
      "epk": {
        "PublicKeyECDH": {
          "crv": "Ed25519",
          "Public": "5tgYXvm8fSXWesF_qVd_nEQxnc78AiA_Xwydup0p01U"}},
      "wmk": "skOy8j33WTzJE899oTu5n_Z5oQlMcbqixfICNI2GJUL5Y7V3o7mzbg"}],
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 1}}

[Empty trailer]]]></artwork>
</figure>
<t>
Frame 2 </t>
<figure anchor="s-14_5-16" suppress-title="true">
<artwork>
<![CDATA[{
  "enc": "A256CBC",
  "Salt": "bL8XIGWZ_uPuQNxV3KkoJA",
  "recipients": [{
      "kid": "MA7L-V7AW-XFYW-4OVM-GPN5-4W3J-676A",
      "epk": {
        "PublicKeyECDH": {
          "crv": "Ed25519",
          "Public": "yhfeHxGp7-Wh9jzbWPRDcN4SpXhnioeQYbgg2Zjp-m0"}},
      "wmk": "5dssLOo2s7vcfn2LpbNqSoWJAJPOufiOh1-L5DYO03575UlxKy1_fA"}],
  "ContentMetaData": "e30",
  "ContainerInfo": {
    "Index": 2}}

[Empty trailer]]]></artwork>
</figure>
</section>
</section>
<section title="Appendix C: Previous Frame Function" anchor="s-15">
<figure anchor="s-15-1" suppress-title="true">
<artwork>
<![CDATA[public long PreviousFrame (long Frame) {
    long x2 = Frame + 1; 
    long d = 1; 

    while (x2 > 0) {
        if ((x2 & 1) == 1) {
            return x2 == 1 ? (d / 2) - 1 : Frame - d; 
            }
        d = d * 2; 
        x2 = x2 / 2; 
        }
    return 0; 
    }]]></artwork>
</figure>
</section>
<section title="Appendix D: Outstanding Issues" anchor="s-16">
<t>
The following issues need to be addressed.</t>
<texttable  anchor="s-16-2">
<ttcol>Issue</ttcol>
<ttcol>Description</ttcol>
<c>X25519</c>
<c>The examples currently use Edwards Curve25519 for encryption. This should be Curve X25519</c>
<c>Indexing</c>
<c>No examples are given of indexing a container</c>
<c>Archive</c>
<c>Should include a file archive example</c>
<c>File Path</c>
<c>Mention the file path security issue in the security considerations</c>
<c>Security Considerations</c>
<c>Write Security considerations</c>
<c>AES-GCM</c>
<c>Switch to using AES GCM in the examples</c>
<c>Witness</c>
<c>Complete handling of witness values.</c>
<c>Schema</c>
<c>Complete the schema documentation</c>
<c>Container Redo</c>
<c>Rework the container/header objects so that these are separate classes and Header is an entry in the Container header.</c>
</texttable >
<t>
</t>
</section>
</middle>
<back>
<references title="Normative References">
<reference anchor="RFC7515">
<front>
<title>JSON Web Signature (JWS)</title>
<author fullname="M. Jones" initials="M." surname="Jones">
<organization/>
<address>
</address>
</author>
<author fullname="J. Bradley" initials="J." surname="Bradley">
<organization/>
<address>
</address>
</author>
<author fullname="N. Sakimura" initials="N." surname="Sakimura">
<organization/>
<address>
</address>
</author>
<date month="May" year="2015"/>
</front>
<seriesInfo name="RFC" value="7515"/>
<seriesInfo name="DOI" value="10.17487/RFC7515"/>
</reference>
<reference anchor="draft-hallambaker-mesh-security">
<front>
<title>Mathematical Mesh 3.0 Part VII: Security Considerations</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="23" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-security-02"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-security-02.txt"/>
</reference>
<reference anchor="draft-hallambaker-mesh-udf">
<front>
<title>Mathematical Mesh 3.0 Part II: Uniform Data Fingerprint.</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="18" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-udf-07"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-udf-07.txt"/>
</reference>
<reference anchor="draft-hallambaker-jsonbcd">
<front>
<title>Binary Encodings for JavaScript Object Notation: JSON-B, JSON-C, JSON-D</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="23" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-jsonbcd-15"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-jsonbcd-15.txt"/>
</reference>
<reference anchor="RFC6838">
<front>
<title>Media Type Specifications and Registration Procedures</title>
<author fullname="N. Freed" initials="N." surname="Freed">
<organization/>
<address>
</address>
</author>
<author fullname="J. Klensin" initials="J." surname="Klensin">
<organization/>
<address>
</address>
</author>
<author fullname="T. Hansen" initials="T." surname="Hansen">
<organization/>
<address>
</address>
</author>
<date month="January" year="2013"/>
</front>
<seriesInfo name="BCP" value="13"/>
<seriesInfo name="RFC" value="6838"/>
<seriesInfo name="DOI" value="10.17487/RFC6838"/>
</reference>
<reference anchor="RFC4949">
<front>
<title>Internet Security Glossary, Version 2</title>
<author fullname="R. Shirey" initials="R." surname="Shirey">
<organization/>
<address>
</address>
</author>
<date month="August" year="2007"/>
</front>
<seriesInfo name="FYI" value="36"/>
<seriesInfo name="RFC" value="4949"/>
<seriesInfo name="DOI" value="10.17487/RFC4949"/>
</reference>
<reference anchor="RFC7518">
<front>
<title>JSON Web Algorithms (JWA)</title>
<author fullname="M. Jones" initials="M." surname="Jones">
<organization/>
<address>
</address>
</author>
<date month="May" year="2015"/>
</front>
<seriesInfo name="RFC" value="7518"/>
<seriesInfo name="DOI" value="10.17487/RFC7518"/>
</reference>
<reference anchor="draft-hallambaker-mesh-architecture">
<front>
<title>Mathematical Mesh 3.0 Part I: Architecture Guide</title>
<author fullname="Phillip Hallam-Baker" initials="P" surname="Hallam-Baker">
<organization/>
<address>
</address>
</author>
<date day="23" month="October" year="2019"/>
</front>
<seriesInfo name="Internet-Draft" value="draft-hallambaker-mesh-architecture-11"/>
<format type="TXT" target="http://www.ietf.org/internet-drafts/draft-hallambaker-mesh-architecture-11.txt"/>
</reference>
<reference anchor="RFC3394">
<front>
<title>Advanced Encryption Standard (AES) Key Wrap Algorithm</title>
<author fullname="J. Schaad" initials="J." surname="Schaad">
<organization/>
<address>
</address>
</author>
<author fullname="R. Housley" initials="R." surname="Housley">
<organization/>
<address>
</address>
</author>
<date month="September" year="2002"/>
</front>
<seriesInfo name="RFC" value="3394"/>
<seriesInfo name="DOI" value="10.17487/RFC3394"/>
</reference>
<reference anchor="RFC2315">
<front>
<title>PKCS #7: Cryptographic Message Syntax Version 1.5</title>
<author fullname="B. Kaliski" initials="B." surname="Kaliski">
<organization/>
<address>
</address>
</author>
<date month="March" year="1998"/>
</front>
<seriesInfo name="RFC" value="2315"/>
<seriesInfo name="DOI" value="10.17487/RFC2315"/>
</reference>
<reference anchor="RFC2119">
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author fullname="S. Bradner" initials="S." surname="Bradner">
<organization/>
<address>
</address>
</author>
<date month="March" year="1997"/>
</front>
<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
<seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>
<reference anchor="RFC7159">
<front>
<title>The JavaScript Object Notation (JSON) Data Interchange Format</title>
<author fullname="T. Bray" initials="T." surname="Bray">
<organization/>
<address>
</address>
</author>
<date month="March" year="2014"/>
</front>
<seriesInfo name="RFC" value="7159"/>
<seriesInfo name="DOI" value="10.17487/RFC7159"/>
</reference>
<reference anchor="RFC5869">
<front>
<title>HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</title>
<author fullname="H. Krawczyk" initials="H." surname="Krawczyk">
<organization/>
<address>
</address>
</author>
<author fullname="P. Eronen" initials="P." surname="Eronen">
<organization/>
<address>
</address>
</author>
<date month="May" year="2010"/>
</front>
<seriesInfo name="RFC" value="5869"/>
<seriesInfo name="DOI" value="10.17487/RFC5869"/>
</reference>
<reference anchor="RFC4880">
<front>
<title>OpenPGP Message Format</title>
<author fullname="J. Callas" initials="J." surname="Callas">
<organization/>
<address>
</address>
</author>
<author fullname="L. Donnerhacke" initials="L." surname="Donnerhacke">
<organization/>
<address>
</address>
</author>
<author fullname="H. Finney" initials="H." surname="Finney">
<organization/>
<address>
</address>
</author>
<author fullname="D. Shaw" initials="D." surname="Shaw">
<organization/>
<address>
</address>
</author>
<author fullname="R. Thayer" initials="R." surname="Thayer">
<organization/>
<address>
</address>
</author>
<date month="November" year="2007"/>
</front>
<seriesInfo name="RFC" value="4880"/>
<seriesInfo name="DOI" value="10.17487/RFC4880"/>
</reference>
<reference anchor="RFC7516">
<front>
<title>JSON Web Encryption (JWE)</title>
<author fullname="M. Jones" initials="M." surname="Jones">
<organization/>
<address>
</address>
</author>
<author fullname="J. Hildebrand" initials="J." surname="Hildebrand">
<organization/>
<address>
</address>
</author>
<date month="May" year="2015"/>
</front>
<seriesInfo name="RFC" value="7516"/>
<seriesInfo name="DOI" value="10.17487/RFC7516"/>
</reference>
<reference anchor="RFC7517">
<front>
<title>JSON Web Key (JWK)</title>
<author fullname="M. Jones" initials="M." surname="Jones">
<organization/>
<address>
</address>
</author>
<date month="May" year="2015"/>
</front>
<seriesInfo name="RFC" value="7517"/>
<seriesInfo name="DOI" value="10.17487/RFC7517"/>
</reference>
<reference anchor="IANAJOSE">
<front>
<title>[Reference Not Found!]</title>
<author initials="" surname="">
<organization/>
<address>
</address>
</author>
<date/>
</front>
</reference>
</references>
<references title="Informative References">
<reference anchor="Davis2001">
<front>
<title>Defective Sign &amp; Encrypt in S/MIME, PKCS#7, MOSS, PEM, PGP, and XML</title>
<author fullname="Don Davis" initials="D." surname="Davis">
<organization/>
<address>
</address>
</author>
<date month="May" year="2001"/>
</front>
</reference>
<reference anchor="ZIPFILE">
<front>
<title>APPNOTE.TXT - .ZIP File Format Specification</title>
<author>
<organization>PKWARE Inc</organization>
<address>
</address>
</author>
<date month="October" year="2014"/>
</front>
<format type="txt" target="https://pkware.cachefly.net/webdocs/casestudies/APPNOTE.TXT"/>
</reference>
<reference anchor="BLOCKCHAIN">
<front>
<title>Blockchain Specification</title>
<author>
<organization>Chain.com</organization>
<address>
</address>
</author>
<date/>
</front>
<format type="html" target="https://chain.com/docs/1.2/protocol/specifications/blockchain"/>
</reference>
<reference anchor="RFC5652">
<front>
<title>Cryptographic Message Syntax (CMS)</title>
<author fullname="R. Housley" initials="R." surname="Housley">
<organization/>
<address>
</address>
</author>
<date month="September" year="2009"/>
</front>
<seriesInfo name="STD" value="70"/>
<seriesInfo name="RFC" value="5652"/>
<seriesInfo name="DOI" value="10.17487/RFC5652"/>
</reference>
</references>
</back>
</rfc>

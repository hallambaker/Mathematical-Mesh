Independent Submission                             Phillip Hallam-Baker
INTERNET-DRAFT                                      ThresholdSecrets.com
Intended Status:                                           July 27, 2020
Expires: January 28, 2021


    Mathematical Mesh 3.0 Part III : Data At Rest Encryption (DARE)
                     draft-hallambaker-mesh-dare-08

Abstract

   This document describes the Data At Rest Encryption (DARE) Envelope
   and Container syntax.

   The DARE Envelope syntax is used to digitally sign, digest,
   authenticate, or encrypt arbitrary content data.

   The DARE Container syntax describes an append-only sequence of
   entries, each containing a DARE Envelope. DARE Containers may support
   cryptographic integrity verification of the entire data container
   content by means of a Merkle tree.

   [Note to Readers]

   Discussion of this draft takes place on the MATHMESH mailing list
   (mathmesh@ietf.org), which is archived at
   https://mailarchive.ietf.org/arch/search/?email_list=mathmesh.

   This document is also available online at .

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts. The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.It is inappropriate to use Internet-Drafts as reference material
   or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 28, 2021

Copyright Notice

   Copyright (c) IETF Trust and the persons identified as the document
   authors. All rights reserved.





Hallam-Baker            Expires January 28, 2021                [Page 1]

                     Mesh: Data At Rest Encryption             July 2020

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of
   publication of this document. Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.
















































Hallam-Baker            Expires January 28, 2021                [Page 2]

                     Mesh: Data At Rest Encryption             July 2020

Table of Contents

   1.  Introduction . . . . . . . . . . . . . . . . . . . . . . . . .  5
      1.1.  Encryption and Integrity  . . . . . . . . . . . . . . . .  5
         1.1.1.  Key Exchange . . . . . . . . . . . . . . . . . . . .  6
         1.1.2.  Data Erasure . . . . . . . . . . . . . . . . . . . .  6
      1.2.  Signature . . . . . . . . . . . . . . . . . . . . . . . .  7
         1.2.1.  Signing Individual Plaintext Envelopes . . . . . . .  7
         1.2.2.  Signing Individual Encrypted Envelopes . . . . . . .  7
         1.2.3.  Signing sequences of envelopes . . . . . . . . . . .  7
      1.3.  Container . . . . . . . . . . . . . . . . . . . . . . . .  8
         1.3.1.  Container Format . . . . . . . . . . . . . . . . . .  8
         1.3.2.  Write  . . . . . . . . . . . . . . . . . . . . . . .  9
         1.3.3.  Encryption and Authentication  . . . . . . . . . . .  9
         1.3.4.  Integrity and Signature  . . . . . . . . . . . . . . 10
         1.3.5.  Redaction  . . . . . . . . . . . . . . . . . . . . . 10
         1.3.6.  Alternative approaches . . . . . . . . . . . . . . . 10
         1.3.7.  Efficiency . . . . . . . . . . . . . . . . . . . . . 11
   2.  Definitions  . . . . . . . . . . . . . . . . . . . . . . . . . 11
      2.1.  Related Specifications  . . . . . . . . . . . . . . . . . 11
      2.2.  Requirements Language . . . . . . . . . . . . . . . . . . 12
      2.3.  Defined terms . . . . . . . . . . . . . . . . . . . . . . 12
   3.  DARE Envelope Architecture . . . . . . . . . . . . . . . . . . 13
      3.1.  Processing Considerations . . . . . . . . . . . . . . . . 14
      3.2.  Content Metadata and Annotations  . . . . . . . . . . . . 14
      3.3.  Encoded Data Sequence . . . . . . . . . . . . . . . . . . 15
      3.4.  Encryption and Integrity  . . . . . . . . . . . . . . . . 16
         3.4.1.  Key Exchange . . . . . . . . . . . . . . . . . . . . 16
         3.4.2.  Key Identifiers  . . . . . . . . . . . . . . . . . . 17
         3.4.3.  Salt Derivation  . . . . . . . . . . . . . . . . . . 17
         3.4.4.  Key Derivation . . . . . . . . . . . . . . . . . . . 18
      3.5.  Signature . . . . . . . . . . . . . . . . . . . . . . . . 18
      3.6.  Algorithms  . . . . . . . . . . . . . . . . . . . . . . . 19
         3.6.1.  Field: kwd . . . . . . . . . . . . . . . . . . . . . 19
   4.  DARE Container Architecture  . . . . . . . . . . . . . . . . . 19
      4.1.  Container Navigation  . . . . . . . . . . . . . . . . . . 19
         4.1.1.  Tree . . . . . . . . . . . . . . . . . . . . . . . . 20
         4.1.2.  Position Index . . . . . . . . . . . . . . . . . . . 20
         4.1.3.  Metadata Index . . . . . . . . . . . . . . . . . . . 21
      4.2.  Integrity Mechanisms  . . . . . . . . . . . . . . . . . . 21
         4.2.1.  Digest Chain calculation . . . . . . . . . . . . . . 21
         4.2.2.  Binary Merkle tree calculation . . . . . . . . . . . 21
         4.2.3.  Signature  . . . . . . . . . . . . . . . . . . . . . 21
   5.  DARE Schema  . . . . . . . . . . . . . . . . . . . . . . . . . 22
      5.1.  Message Classes   . . . . . . . . . . . . . . . . . . . . 22
         5.1.1.  Structure: DareEnvelopeSequence  . . . . . . . . . . 22
      5.2.  Header and Trailer Classes  . . . . . . . . . . . . . . . 23
         5.2.1.  Structure: DareTrailer   . . . . . . . . . . . . . . 23
         5.2.2.  Structure: DareHeader  . . . . . . . . . . . . . . . 23
         5.2.3.  Structure: ContentMeta   . . . . . . . . . . . . . . 24
      5.3.  Cryptographic Data  . . . . . . . . . . . . . . . . . . . 25



Hallam-Baker            Expires January 28, 2021                [Page 3]

                     Mesh: Data At Rest Encryption             July 2020

         5.3.1.  Structure: DareSignature   . . . . . . . . . . . . . 25
         5.3.2.  Structure: X509Certificate   . . . . . . . . . . . . 26
         5.3.3.  Structure: DareRecipient   . . . . . . . . . . . . . 26
   6.  DARE Container Schema  . . . . . . . . . . . . . . . . . . . . 26
      6.1.  Container Headers   . . . . . . . . . . . . . . . . . . . 26
         6.1.1.  Structure: ContainerInfo   . . . . . . . . . . . . . 26
      6.2.  Index Structures  . . . . . . . . . . . . . . . . . . . . 27
         6.2.1.  Structure: ContainerIndex  . . . . . . . . . . . . . 27
         6.2.2.  Structure: IndexPosition   . . . . . . . . . . . . . 27
         6.2.3.  Structure: KeyValue  . . . . . . . . . . . . . . . . 28
         6.2.4.  Structure: IndexMeta   . . . . . . . . . . . . . . . 28
   7.  Dare Container Applications  . . . . . . . . . . . . . . . . . 28
      7.1.  Catalog . . . . . . . . . . . . . . . . . . . . . . . . . 28
      7.2.  Spool . . . . . . . . . . . . . . . . . . . . . . . . . . 29
      7.3.  Archive . . . . . . . . . . . . . . . . . . . . . . . . . 29
   8.  Future Work  . . . . . . . . . . . . . . . . . . . . . . . . . 30
      8.1.  Terminal integrity check  . . . . . . . . . . . . . . . . 30
      8.2.  Terminal index record . . . . . . . . . . . . . . . . . . 30
      8.3.  Deferred indexing . . . . . . . . . . . . . . . . . . . . 30
   9.  Security Considerations  . . . . . . . . . . . . . . . . . . . 31
      9.1.  Encryption/Signature nesting  . . . . . . . . . . . . . . 31
      9.2.  Side channel  . . . . . . . . . . . . . . . . . . . . . . 31
      9.3.  Salt reuse  . . . . . . . . . . . . . . . . . . . . . . . 31
   10.  IANA Considerations . . . . . . . . . . . . . . . . . . . . . 31
   11.  Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . 31
   12.  Appendix A: DARE Envelope Examples and Test Vectors . . . . . 31
   13.  Test Examples   . . . . . . . . . . . . . . . . . . . . . . . 31
      13.1.   Plaintext Message   . . . . . . . . . . . . . . . . . . 32
      13.2.   Plaintext Message with EDS  . . . . . . . . . . . . . . 32
      13.3.   Encrypted Message   . . . . . . . . . . . . . . . . . . 32
      13.4.   Signed Message  . . . . . . . . . . . . . . . . . . . . 34
      13.5.   Signed and Encrypted Message  . . . . . . . . . . . . . 35
   14.  Appendix B: DARE Container Examples and Test Vectors  . . . . 35
      14.1.  Simple container   . . . . . . . . . . . . . . . . . . . 36
      14.2.  Payload and chain digests  . . . . . . . . . . . . . . . 36
      14.3.  Merkle Tree  . . . . . . . . . . . . . . . . . . . . . . 38
      14.4.  Signed container   . . . . . . . . . . . . . . . . . . . 40
      14.5.  Encrypted container  . . . . . . . . . . . . . . . . . . 41
   15.  Appendix C: Previous Frame Function   . . . . . . . . . . . . 43
   16.  Appendix D: Outstanding Issues  . . . . . . . . . . . . . . . 44
   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 44
      Normative References  . . . . . . . . . . . . . . . . . . . . . 44
      Informative References  . . . . . . . . . . . . . . . . . . . . 46
   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 46










Hallam-Baker            Expires January 28, 2021                [Page 4]

                     Mesh: Data At Rest Encryption             July 2020

1. Introduction

   This document describes the Data At Rest Encryption (DARE) Envelope
   and Container Syntax. The DARE Envelope syntax is used to digitally
   sign, digest, authenticate, or encrypt arbitrary message content. The
   DARE Container syntax describes an append-only sequence of data
   frames, each containing a DARE Envelope that supports efficient
   incremental signature and encryption.

   The DARE Envelope Syntax is based on a subset of the JSON Web
   Signature  and JSON Web Encryption  standards and shares many fields
   and semantics. The processing model and data structures have been
   streamlined to remove alternative means of specifying the same
   content and to enable multiple data sequences to be signed and
   encrypted under a single master encryption key without compromise to
   security.

   A DARE Envelope consists of a Header, Payload and an optional
   Trailer. To enable single pass encoding and decoding, the Header
   contains all the information required to perform cryptographic
   processing of the Payload and authentication data (digest, MAC,
   signature values) MAY be deferred to the Trailer section.

   A DARE Container is an append-only log format consisting of a
   sequence of frames. Cryptographic enhancements (signature,
   encryption) may be applied to individual frames or to sets of frames.
   Thus, a single key exchange may be used to provide a master key to
   encrypt multiple frames and a single signature may be used to
   authenticate all the frames in the container up to and including the
   frame in which the signature is presented.

   The DARE Envelope syntax may be used either as a standalone
   cryptographic message syntax or as a means of presenting a single
   DARE Container frame together with the complete cryptographic context
   required to verify the contents and decrypt them.

1.1. Encryption and Integrity

   A key innovation in the DARE Envelope Syntax is the separation of key
   exchange and data encryption operations so that a Master Key (MK)
   established in a single exchange to be applied to multiple data
   sequences. This means that a single public key operation MAY be used
   to encrypt and/or authenticate multiple parts of the same DARE
   Envelope or multiple frames in a DARE Container.

   To avoid reuse of the key and to avoid the need to communicate
   separate IVs, each octet sequence is encrypted under a different
   encryption key (and IV if required) derived from the Master Key by
   means of a salt that is unique for each octet sequence that is
   encrypted. The same approach is used to generate keys for calculating
   a MAC over the octet sequence if required. This approach allows



Hallam-Baker            Expires January 28, 2021                [Page 5]

                     Mesh: Data At Rest Encryption             July 2020

   encryption and integrity protections to be applied to the envelope
   payload, to header or trailer fields or to application defined
   Enhanced Data Sequences in the header or trailer.

1.1.1. Key Exchange

   Traditional cryptographic containers describe the application of a
   single key exchange to encryption of a single octet sequence.
   Examples include PCKS#7/CMS , OpenPGP  and JSON Web Encryption .

   To encrypt data using RSA, the encoder first generates a random
   encryption key and initialization vector (IV). The encryption key is
   encrypted under the public key of each recipient to create a per-
   recipient decryption entry. The encryption key, plaintext and IV are
   used to generate the ciphertext (figure 1).

   This approach is adequate for the task of encrypting a single octet
   stream. It is less than satisfactory when encrypting multiple octet
   streams or very long streams for which a rekeying operation is
   desirable.

   In the DARE approach, key exchange and key derivation are separate
   operations and keys MAY be derived for encryption or integrity
   purposes or both. A single key exchange MAY be used to derive keys to
   apply encryption and integrity enhancements to multiple data
   sequences.

   The DARE key exchange begins with the same key exchange used to
   produce the CEK in JWE but instead of using the CEK to encipher data
   directly, it is used as one of the inputs to a Key Derivation
   Function (KDF) that is used to derive parameters for each block of
   data to be encrypted. To avoid the need to introduce additional
   terminology, the term 'CEK' is still used to describe the output of
   the key agreement algorithm (including key unwrapping if required)
   but it is more appropriately described as a Master Key (figure 2).

   A Master Key may be used to encrypt any number of data items. Each
   data item is encrypted under a different encryption key and IV (if
   required). This data is derived from the Master Key using the HKDF
   function  using a different salt for each data item and separate info
   tags for each cryptographic function (figure 3).

   This approach to encryption offers considerably greater flexibility
   allowing the same format for data item encryption to be applied at
   the transport, message or field level.

1.1.2. Data Erasure

   Each encrypted DARE Envelope specifies a unique Master Salt value of
   at least 128 bits which is used to derive the salt values used to
   derive cryptographic keys for the envelope payload and annotations.



Hallam-Baker            Expires January 28, 2021                [Page 6]

                     Mesh: Data At Rest Encryption             July 2020


   Erasure of the Master Salt value MAY be used to effectively render
   the envelope payload and annotations undecipherable without altering
   the envelope payload data. The work factor for decryption will be
   O(2^128) even if the decryption key is compromised.

1.2. Signature

   As with encryption, DARE Envelope signatures MAY be applied to an
   individual envelope or a sequence of envelope.

1.2.1. Signing Individual Plaintext Envelopes

   When an individual plaintext envelope is signed, the digest value
   used to create the signature is calculated over the binary value of
   the payload data. That is, the value of the payload before the
   encoding (Base-64, JSON-B) is applied.

1.2.2. Signing Individual Encrypted Envelopes

   When an individual plaintext envelope is signed, the digest value
   used to create the signature is calculated over the binary value of
   the payload data. That is, the value of the payload after encryption
   but before the encoding (Base-64, JSON-B) is applied.

   Use of signing and encryption in combination presents the risk of
   subtle attacks depending on the order in which signing and encryption
   take place .

   Na?ve approaches in which an envelope is encrypted and then signed
   present the possibility of a surreptitious forwarding attack. For
   example, Alice signs an envelope and sends it to Mallet who then
   strips off Alice's signature and sends the envelope to Bob.

   Na?ve approaches in which an envelope is signed and then encrypted
   present the possibility of an attacker claiming authorship of a
   ciphertext. For example, Alice encrypts a ciphertext for Bob and then
   signs it. Mallet then intercepts the envelope and sends it to Bob.

   While neither attack is a concern in all applications, both attacks
   pose potential hazards for the unwary and require close inspection of
   application protocol design to avoid exploitation.

   To prevent these attacks, each signature on an envelope that is
   signed and encrypted MUST include a witness value that is calculated
   by applying a MAC function to the signature value as described in
   section XXX.







Hallam-Baker            Expires January 28, 2021                [Page 7]

                     Mesh: Data At Rest Encryption             July 2020

1.2.3. Signing sequences of envelopes

   To sign multiple envelopes with a single signature, we first
   construct a Merkle tree of the envelope payload digest values and
   then sign the root of the Merkle tree.

   [This is not yet implemented but will be soon.]

1.3. Container

   DARE Container is a message and file syntax that allows a sequence of
   data frames to be represented with cryptographic integrity,
   signature, and encryption enhancements to be constructed in an append
   only format.

   The format is designed to meet the requirements of a wide range of
   use cases including:

         *  Recording transactions in persistent storage.

         *  Synchronizing transaction logs between hosts.

         *  File archive.

         *  Message spool.

         *  Signing and encrypting single data items.

         *  Incremental encryption and authentication of server logs.

1.3.1. Container Format

   A Container consists of a sequence of variable length Frames. Each
   frame consists of a forward length indicator, the framed data and a
   reverse length indicator. The reverse length indicator is written out
   backwards allowing the length and thus the frame to be read in the
   reverse direction:

   Each frame contains a single DARE Envelope consisting of a Header,
   Payload and Trailer (if required). The first frame in a container
   describes the container format options and defaults. These include
   the range of encoding options for frame metadata supported and the
   container profiles to which the container conforms.

   All internal data formats support use of pointers of up to 64 bits
   allowing containers of up to 18 exabytes to be written.








Hallam-Baker            Expires January 28, 2021                [Page 8]

                     Mesh: Data At Rest Encryption             July 2020

   Five container types are currently specified:

         Simple

         Tree

         Digest

         Chain

         Merkle Tree

1.3.2. Write

   In normal circumstances, Containers are written as an append only
   log. As with Envelopes, integrity information (payload digest,
   signatures) is written to the entry trailer. Thus, large payloads may
   be written without the need to buffer the payload data provided that
   the content length is known in advance.

   Should exceptional circumstances require, Container entries MAY be
   erased by overwriting the Payload and/or parts of the Header content
   without compromising the ability to verify other entries in the
   container. If the entry Payload is encrypted, it is sufficient to
   erase the container salt value to render the container entry
   effectively inaccessible (though recovery might still be possible if
   the original salt value can be recovered from the storage media.

1.3.3. Encryption and Authentication

   Frame payloads and associated attributes MAY be encrypted and/or
   authenticated in the same manner as Envelopes.

   Incremental encryption is supported allowing encryption parameters
   from a single public key exchange operation to be applied to encrypt
   multiple frames. The public key exchange information is specified in
   the first encrypted frame and subsequent frames encrypted under those
   parameters specify the location at which the key exchange information
   is to be found by means of the ExchangePosition field which MUST
   specify a location that is earlier in the file.

   To avoid cryptographic vulnerabilities resulting from key re-use, the
   DARE key exchange requires that each encrypted sequence use an
   encryption key and initialization vector derived from the master key
   established in the public key exchange by means of a unique salt.

   Each Envelope and by extension, each Container frame MUST specify a
   unique salt value of at least 128 bits. Since the encryption key is
   derived from the salt value by means of a Key Derivation Function,
   erasure of the salt MAY be used as a means of rendering the payload
   plaintext value inaccessible without changing the payload value.



Hallam-Baker            Expires January 28, 2021                [Page 9]

                     Mesh: Data At Rest Encryption             July 2020


1.3.4. Integrity and Signature

   Signatures MAY be applied to a payload digest, the final digest in a
   chain or tree. The chain and tree digest modes allow a single
   signature to be used to authenticate all frame payloads in a
   container.

   The tree signature mode is particularly suited to applications such
   as file archives as it allows files to be verified individually
   without requiring the signer to sign each individually. Furthermore,
   in applications such as code signing, it allows a single signature to
   be used to verify both the integrity of the code and its membership
   of the distribution.

   As with DARE Envelope, the signature mechanism does not specify the
   interpretation of the signature semantics. The presence of a
   signature demonstrates that the holder of the private key applied it
   to the specified digest value but not their motive for doing so.
   Describing such semantics is beyond the scope of this document and is
   deferred to future work.

1.3.5. Redaction

   The chief disadvantage of using an append-only format is that
   containers only increase in size. In many applications, much of the
   data in the container becomes redundant or obsolete and a process
   analogous to garbage collection is required. This process is called
   redaction.

   The simplest method of redaction is to create a new container and
   sequentially copy each entry from the old container to the new,
   discarding redundant frames and obsolete header information.

   For example, partial index records may be consolidated into a single
   index record placed in the last frame of the container. Unnecessary
   signature and integrity data may be discarded and so on.

   While redaction could in principle be effected by moving data in-
   place in the existing container, supporting this approach in a robust
   fashion is considerably more complex as it requires backward
   references in subsequent frames to be overridden as each frame is
   moved.

1.3.6. Alternative approaches

   Many file proprietary formats are in use that support some or all of
   these capabilities but only a handful have public, let alone open,
   standards. DARE Container is designed to provide a superset of the
   capabilities of existing message and file syntaxes, including:




Hallam-Baker            Expires January 28, 2021               [Page 10]

                     Mesh: Data At Rest Encryption             July 2020

         *  Cryptographic Message Syntax  defines a syntax used to
            digitally sign, digest, authenticate, or encrypt arbitrary
            message content.

         *  The.ZIP File Format specification  developed by Phil Katz.

         *  The BitCoin Block chain .

         *  JSON Web Encryption and JSON Web Signature

   Attempting to make use of these specifications in a layered fashion
   would require at least three separate encoders and introduce
   unnecessary complexity. Furthermore, there is considerable overlap
   between the specifications providing multiple means of achieving the
   same ends, all of which must be supported if decoders are to work
   reliably.

1.3.7. Efficiency

   Every data format represents a compromise between different concerns,
   in particular:

         Compactness

         Memory Overhead

         Number of Operations

         Number of Disk Seek Operations

   While the cost of storage of all types has declined rapidly over the
   past decades, so has the amount of data to be stored. DARE Container
   represents a pragmatic balance of these considerations for current
   technology. In particular, since payload volumes are likely to be
   very large, memory and operational efficiency are considered higher
   priorities than compactness.

2. Definitions

2.1. Related Specifications

   The DARE Envelope and Container formats are based on the following
   existing standards and specifications.











Hallam-Baker            Expires January 28, 2021               [Page 11]

                     Mesh: Data At Rest Encryption             July 2020

         Object serialization

         Message syntax

         Cryptographic primitives.

         Cryptographic algorithms

2.2. Requirements Language

   The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
   "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
   document are to be interpreted as described in .

2.3. Defined terms

   The terms "Authentication Tag", "Content Encryption Key", "Key
   Management Mode", "Key Encryption", "Direct Key Agreement", "Key
   Agreement with Key Wrapping" and "Direct Encryption" are defined in
   the JWE specification .

   The terms "Authentication", "Ciphertext", "Digital Signature",
   "Encryption", "Initialization Vector (IV)", "Message Authentication
   Code (MAC)", "Plaintext" and "Salt" are defined by the Internet
   Security Glossary, Version 2 .





























Hallam-Baker            Expires January 28, 2021               [Page 12]

                     Mesh: Data At Rest Encryption             July 2020

         Annotated Envelope

         Authentication Data

         Complete Envelope

         Detached Envelope

         Encryption Context

         Encoded data sequence (EDS)

         Enhancement

         Generator

         Group Encryption Key

         Group Encryption Key Identifier

         Master Key (MK)

         Recipient

         Related Envelope

         Uniform Data Fingerprint (UDF)

3. DARE Envelope Architecture

   A DARE Envelope is a sequence of three parts:

         Header

         Payload

         Trailer

   For example, the following sequence is a JSON encoded Envelope with
   an empty header, a payload of zero length and an empty trailer:

   [ {}, "", {} ]

   DARE Envelopes MAY be encoded using JSON serialization or a binary
   serialization for greater efficiency.









Hallam-Baker            Expires January 28, 2021               [Page 13]

                     Mesh: Data At Rest Encryption             July 2020

         JSON

         JSON-B

         JSON-C

   DARE Envelope processors MUST support JSON serialization and SHOULD
   support JSON-B serialization.

3.1. Processing Considerations

   The DARE Envelope Syntax supports single pass encoding and decoding
   without buffering of data. All the information required to begin
   processing a DARE envelope (key agreement information, digest
   algorithms), is provided in the envelope header. All the information
   that is derived from envelope processing (authentication codes,
   digest values, signatures) is presented in the envelope trailer.

   The choice of envelope encoding does not affect the semantics of
   envelope processing. A DARE Envelope MAY be reserialized under the
   same serialization or converted from any of the specified
   serialization to any other serialization without changing the
   semantics or integrity properties of the envelope.

3.2. Content Metadata and Annotations

   A header MAY contain header fields describing the payload content.
   These include:

         ContentType

         Annotations

   For example, consider the following mail message:

   From: Alice@example.com
   To: bob@example.com
   Subject: TOP-SECRET Product Launch Today!
   
   The CEO told me the product launch is today. Tell no-one!

   Existing encryption approaches require that header fields such as the
   subject line be encrypted  with the body of the message or not
   encrypted at all. Neither approach is satisfactory. In this example,
   the subject line gives away important information that the sender
   probably assumed would be encrypted. But if the subject line is
   encrypted together with the message body, a mail client must retrieve
   at least part of the message body to provide a  'folder' view.






Hallam-Baker            Expires January 28, 2021               [Page 14]

                     Mesh: Data At Rest Encryption             July 2020

   The plaintext form of the equivalent DARE Message encoding is:

   [{
       "Annotations":["iAEBiBdGcm9tOiBBbGljZUBleGFtcGxlLmNvbYgA",
         "iAECiBNUbzogYm9iQGV4YW1wbGUuY29tiAA",
         "iAEDiClTdWJqZWN0OiBUT1AtU0VDUkVUIFByb2R1Y3QgTGF1bmNoIFRvZGF5
     IYgA"
         ],
       "ContentMetaData":"ewogICJjdHkiOiAiYXBwbGljYXRpb24vZXhhbXBsZS1t
     YWlsIn0"},
     "VGhlIENFTyB0b2xkIG1lIHRoZSBwcm9kdWN0IGxhdW5jaCBpcyB0b2RheS4gVGVs
     bCBuby1vbmUh"
     ]

   This contains the same information as before but the mail message
   headers are  now presented as a list of Encoded Data Sequences.

3.3. Encoded Data Sequence

   An encoded data sequence (EDS) is a sequence of octets that encodes a
   data sequence according to cryptographic enhancements specified in
   the context in which it is presented. An EDS MAY be encrypted and MAY
   be authenticated by means of a MAC. The keys and other cryptographic
   parameters used to apply these enhancements are derived from the
   cryptographic context and a Salt prefix specified in the EDS itself.

   An EDS sequence contains exactly three binary fields encoded in JSON-
   B serialization as follows:

         Salt Prefix

         Body

         Authentication Tag

   Requiring all three fields to be present, even in cases where they
   are unnecessary simplifies processing at the cost of up to six
   additional data bytes.

   The encoding of the 'From' header of the previous example as a
   plaintext EDS is as follows:

   88 01 
     01 
   88 17 
     46 72 6f 6d 3a 20 41 6c   69 63 65 40 65 78 61 6d 
     70 6c 65 2e 63 6f 6d 
   88 00 
   





Hallam-Baker            Expires January 28, 2021               [Page 15]

                     Mesh: Data At Rest Encryption             July 2020

3.4. Encryption and Integrity

   Encryption and integrity protections MAY be applied to any DARE
   Envelope Payload and Annotations.

   The following is an encrypted version of the message shown earlier.
   The payload and annotations have both increased in size as a result
   of the block cipher padding. The header now includes Recipients and
   Salt fields to enable the content to be decoded.

   [{
       "enc":"A256CBC",
       "kid":"EBQP-KM4Q-N32E-JM5V-DF4Y-EPZ3-PPDA",
       "Salt":"1D0GBsw_YuKSA8t7ScnsLw",
       "Annotations":["iAEBiCBMuc8j9gaxmEgKqHwmxOLwRXtvc_NIl9TnCl1THa1y
     dA",
         "iAECiCCmaGajbkqu-MnAxtca7ktmFcDgWSF64ezieKCc8P947g",
         "iAEDiDBOZKsqsyk-KYrcT3ll-Odxcj6kbtVSnx3sLC2EEnPFdjZNv6Pf1-eQ
     S1ST1W4mcDk"
         ],
       "recipients":[{
           "kid":"MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
           "epk":{
             "PublicKeyECDH":{
               "crv":"Ed25519",
               "Public":"m-3HyC2NCd5ik788zg8YxHHPQvtKM0kx3R-bOEJHInw"}},
           "wmk":"7r4CXNsg8hgwU9vNv3XmbIn9dzgdDsMN83WPuwv7xqVygBKyvZrX
     Xg"}
         ],
       "ContentMetaData":"ewogICJjdHkiOiAiYXBwbGljYXRpb24vZXhhbXBsZS1t
     YWlsIn0"},
     "TRmSam6XnPWRgos9zu3Gs_PPn40zwqVAUx4JcXIEMeSopahOxCRPsAw4YFDNJtNs
     iPOmY81DRW9rgRV-uSRSFg"
     ]

3.4.1. Key Exchange

   The DARE key exchange is based on the JWE key exchange except that
   encryption modes are intentionally limited and the output of the key
   exchange is the DARE Master Key rather than the Content Encryption
   Key.

   A DARE Key Exchange MAY contain any number of Recipient entries, each
   providing a means of decrypting the Master Key using a different
   private key.

   If the Key Exchange mechanism supports message recovery, Direct Key
   Agreement is used, in all other cases, Key Wrapping is used.






Hallam-Baker            Expires January 28, 2021               [Page 16]

                     Mesh: Data At Rest Encryption             July 2020

   This approach allows envelopes with one intended recipient to be
   handled in the exact same fashion as envelopes with multiple
   recipients. While this does require an additional key wrapping
   operation, that could be avoided if an envelope has exactly one
   intended recipient, this is offset by the reduction in code
   complexity.

   If the key exchange algorithm does not support message recovery (e.g.
   Diffie Hellman and Elliptic Curve Diffie-Hellman), the HKDF Extract-
   and-Expand Key Derivation Function is used to derive a master key
   using the following info tag:

         "dare-master" [64 61 72 65 2d 6d 61 73 74 65 72]

   The master key length is the maximum of the key size of the
   encryption algorithm specified by the key exchange header, the key
   size of the MAC algorithm specified by the key exchange header (if
   used) and 256.

3.4.2. Key Identifiers

   The JWE/JWS specifications define a kid field for use as a key
   identifier but not how the identifier itself is constructed. All DARE
   key identifiers are either UDF key fingerprints  or Mesh/Recrypt
   Group Key Identifiers.

   A UDF fingerprint is formed as the digest of an IANA content type and
   the digested data. A UDF key fingerprint is formed with the content
   type application/pkix-keyinfo and the digested data is the ASN.1 DER
   encoded PKIX certificate keyInfo sequence for the corresponding
   public key.

   A Group Key Identifier has the form <fingerprint>@<domain>. Where
   <fingerprint> is a UDF key fingerprint and <domain> is the DNS
   address of a service that provides the encryption service to support
   decryption by group members.

3.4.3. Salt Derivation

   A Master Salt is a sequence of 16 or more octets that is specified in
   the Salt field of the header.

   The Master Salt is used to derive salt values for the envelope
   payload and associated encoded data sequences as follows.










Hallam-Baker            Expires January 28, 2021               [Page 17]

                     Mesh: Data At Rest Encryption             July 2020

         Payload

         EDS

   Encoders SHOULD NOT generate salt values that exceed 1024 octets.

   The salt value is opaque to the DARE encoding but MAY be used to
   encode application specific semantics including:

         *  Frame number to allow reassembly of a data sequence split
            over a sequence of envelopes which may be delivered out of
            order.

         *  Transmit the Master Key in the manner of a Kerberos ticket.

         *  Identify the Master Key under which the Enhanced Data
            Sequence was generated.

         *  Enable access to the plaintext to be eliminated by erasure
            of the encryption key.

   For data erasure to be effective, the salt MUST be constructed so
   that the difficulty of recovering the key is sufficiently high that
   it is infeasible. For most purposes, a salt with 128 bits of
   appropriately random data is sufficient.

3.4.4. Key Derivation

   Encryption and/or authentication keys are derived from the Master Key
   using a Extract-and-Expand Key Derivation Function as follows:

         0) The Master Key and salt value are used to extract the PRK
            (pseudorandom key)

         0) The PRK is used to derive the algorithm keys using the
            application specific information input for that key type.

   The application specific information inputs are:

         "dare-encrypt" [64 61 72 65 2d 65 6e 63 72 79 70 74]

         "dare-iv" [64 61 72 65 2d 65 6e 63 72 79 70 74]

         "dare-mac" [dare-mac]

3.5. Signature

   While encryption and integrity enhancements can be applied to any
   part of a DARE Envelope, signatures are only applied to payload
   digest values calculated over one or more envelope payloads.




Hallam-Baker            Expires January 28, 2021               [Page 18]

                     Mesh: Data At Rest Encryption             July 2020

   The payload digest value for an envelope is calculated over the
   binary payload data. That is, after any encryption enhancement has
   been applied but before the envelope encoding is applied. This allows
   envelopes to be converted from one encoding to another without
   affecting signature verification.

         Single Payload

         Multiple Payload.

   Verification of a multiple payload signature naturally requires the
   additional digest values required to construct the Merkle Tree. These
   are provided in the Trailer in a format that permits multiple signers
   to reference the same tree data.

3.6. Algorithms

3.6.1. Field: kwd

   The key wrapping and derivation algorithms.

   Since the means of public key exchange is determined by the key
   identifier of the recipient key, it is only necessary to specify the
   algorithms used for key wrapping and derivation.

   The default (and so far only) algorithm is kwd-aes-sha2-256-256.

   Advanced Encryption Standard (AES) Key Wrap with Padding Algorithm
   is used to wrap the Master Exchange Key. AES 256 is used.

   HMAC-based Extract-and-Expand Key Derivation Function  is used for
   key derivation. SHA-2-256 is used for the hash function.

4. DARE Container Architecture

4.1. Container Navigation

   Three means of locating frames in a container are supported:

         Sequential

         Binary search

         Index

   All DARE Containers support sequential access. Only tree and Merkle
   tree containers support binary search access. An index frame MAY be
   written appended to any container and provides O(1) access to any
   frame listed in the index.





Hallam-Baker            Expires January 28, 2021               [Page 19]

                     Mesh: Data At Rest Encryption             July 2020

   Two modes of compilation are considered:

         Monolithic

         Incremental

   In the monolithic mode, navigation requirements are best met by
   writing an index frame to the end of the container when it is
   complete. It is not necessary to construct a binary search tree
   unless a Merkle tree integrity check is required.

   In the incremental mode, Binary search provides an efficient means of
   locating frames by frame number but not by key. Writing a complete
   index to the container every m write operations provides O(m) search
   access but requires O(n^2) storage.

   Use of partial indexes provides a better compromise between speed and
   efficiency. A partial index is written out every m frames where m is
   a power of two. A complete index is written every time a binary tree
   apex record is written. This approach provides for O(log_2(n)) search
   with incremental compilation with approximately double the overhead
   of the monolithic case.

4.1.1. Tree

   Binary search is supported by means of the TreePosition parameter
   specified in the FrameHeader. This parameter specifies the value of
   the immediately preceding apex.

   Calculation of the immediately preceding apex is most easily
   described by representing the array index in binary with base of 1
   (rather than 0). An array index that is a power of 2 (2, 4, 8, 16,
   etc.) will be the apex of a complete tree. Every other array index
   has the value of the sum of a set of powers of 2 and the immediately
   preceding apex will be the value of the next smallest power of 2 in
   the sum.

   For example, to find the immediately preceding apex for frame 5, we
   add 1 to get 6. 6 = 4 + 2, so we ignore the 2 and the preceding frame
   is 4.

   The values of Tree Position are shown for the first 8 frames in
   figure xx below:

   An algorithm for efficiently calculating the immediately preceding
   apex is provided in Appendix C.








Hallam-Baker            Expires January 28, 2021               [Page 20]

                     Mesh: Data At Rest Encryption             July 2020

4.1.2. Position Index

   Contains a table of frame number, position pairs pointing to prior
   locations in the file.

4.1.3. Metadata Index

   Contains a list of IndexMeta entries. Each entry contains a metadata
   description and a list of frame indexes (not positions) of frames
   that match the description.

4.2. Integrity Mechanisms

   Frame sequences in a DARE container MAY be protected against a frame
   insertion attack by means of a digest chain, a binary Merkle tree or
   both.

4.2.1. Digest Chain calculation

   A digest chain is simple to implement but can only be verified if the
   full chain of values is known. Appending a frame to the chain has
   O(1) complexity but verification has O(n) complexity:

   The value of the chain digest for the first frame (frame 0) is
   H(H(null)+H(Payload_0)), where null is a zero length octet sequence
   and payloadn is the sequence of payload data bytes for frame n

   The value of the chain digest for frame n is H(H(Payload_n-1
   +H(Payloadn)), where A+B stands for concatenation of the byte
   sequences A and B.

4.2.2. Binary Merkle tree calculation

   The tree index mechanism describe earlier may be used to implement a
   binary Merkle tree. The value TreeDigest specifies the apex value of
   the tree for that node.

   Appending a frame to the chain has O(log_2 (n)) complexity provided
   that the container format supports at least the binary tree index.
   Verifying a chain has O(log_2 (n)) complexity, provided that the set
   of necessary digest inputs is known.

   To calculate the value of the tree digest for a node, we first
   calculate the values of all the sub trees that have their apex at
   that node and then calculate the digest of that value and the
   immediately preceding local apex.








Hallam-Baker            Expires January 28, 2021               [Page 21]

                     Mesh: Data At Rest Encryption             July 2020

4.2.3. Signature

   Payload data MAY be signed using a JWS  as applied in the Envelope.

   Signatures are specified by the Signatures parameter in the content
   header. The data that the signature is calculated over is defined by
   the typ parameter of the Signature as follows.

         Payload

         Chain

         Tree

   If the typ parameter is absent, the value Payload is implied.

   A frame MAY contain multiple signatures created with the same signing
   key and different typ values.

   The use of signatures over chain and tree digest values permit
   multiple frames to be validated using a single signature verification
   operation.

5. DARE Schema

   A DARE Envelope consists of a Header, an Enhanced Data Sequence (EDS)
   and  an optional trailer. This section describes the JSON data fields
   used to  construct headers, trailers and complete messages.

   Wherever possible, fields from JWE, JWS and JWK have been used. In
   these cases, the fields have the exact same semantics. Note however
   that the classes in  which these fields are presented have different
   structure and nesting.

5.1. Message Classes

   A DARE Message contains a single DAREMessageSequence in either the
   JSON or  Compact serialization as directed by the protocol in which
   it is applied.

5.1.1. Structure: DareEnvelopeSequence

   A DARE Message containing Header, EDS and Trailer in JSON object
   encoding. Since a DAREMessage is almost invariably presented in JSON
   sequence or compact encoding, use of the DAREMessage subclass is
   preferred.

   Although a DARE Message is functionally an object, it is serialized
   as  an ordered sequence. This ensures that the message header field
   will always precede the body in a serialization, this allowing
   processing of the header information to be performed before the



Hallam-Baker            Expires January 28, 2021               [Page 22]

                     Mesh: Data At Rest Encryption             July 2020

   entire body has been received.

         Header: DareHeader (Optional)

         Body: Binary (Optional)

         Trailer: DareTrailer (Optional)

5.2. Header and Trailer Classes

   A DARE Message sequence MUST contain a (possibly empty) DAREHeader
   and MAY contain a DARETrailer.

5.2.1. Structure: DareTrailer

   A DARE Message Trailer

         Signatures: DareSignature [0..Many]

         SignedData: Binary (Optional)

         PayloadDigest: Binary (Optional)

         ChainDigest: Binary (Optional)

         TreeDigest: Binary (Optional)

5.2.2. Structure: DareHeader

         Inherits: DareTrailer

   A DARE Message Header. Since any field that is present in a trailer
   MAY be  placed in a header instead, the message header inherits from
   the trailer.




















Hallam-Baker            Expires January 28, 2021               [Page 23]

                     Mesh: Data At Rest Encryption             July 2020

         EnvelopeID: String (Optional)

         EncryptionAlgorithm: String (Optional)

         DigestAlgorithm: String (Optional)

         KeyIdentifier: String (Optional)

         Salt: Binary (Optional)

         Malt: Binary (Optional)

         Cloaked: Binary (Optional)

         EDSS: Binary [0..Many]

         Signers: DareSignature [0..Many]

         Recipients: DareRecipient [0..Many]

         ContentMetaData: Binary (Optional)

         ContainerInfo: ContainerInfo (Optional)

         ContainerIndex: ContainerIndex (Optional)

         Received: DateTime (Optional)



























Hallam-Baker            Expires January 28, 2021               [Page 24]

                     Mesh: Data At Rest Encryption             July 2020

5.2.3. Structure: ContentMeta

         UniqueID: String (Optional)

         Labels: String [0..Many]

         KeyValues: KeyValue [0..Many]

         MessageType: String (Optional)

         ContentType: String (Optional)

         Paths: String [0..Many]

         Filename: String (Optional)

         Event: String (Optional)

         Created: DateTime (Optional)

         Modified: DateTime (Optional)

         Expire: DateTime (Optional)

         First: Integer (Optional)

         Previous: Integer (Optional)

5.3. Cryptographic Data

   DARE Message uses the same fields as JWE and JWS but with different
   structure. In particular, DARE messages MAY have multiple recipients
   and multiple signers.





















Hallam-Baker            Expires January 28, 2021               [Page 25]

                     Mesh: Data At Rest Encryption             July 2020

5.3.1. Structure: DareSignature

   The signature value

         Dig: String (Optional)

         Alg: String (Optional)

         KeyIdentifier: String (Optional)

         Certificate: X509Certificate (Optional)

         Path: X509Certificate (Optional)

         Manifest: Binary (Optional)

         SignatureValue: Binary (Optional)

         WitnessValue: Binary (Optional)

5.3.2. Structure: X509Certificate

         X5u: String (Optional)

         X5: Binary (Optional)

5.3.3. Structure: DareRecipient

   Recipient information

         KeyIdentifier: String (Optional)

         KeyWrapDerivation: String (Optional)

         WrappedMasterKey: Binary (Optional)

         RecipientKeyData: String (Optional)

















Hallam-Baker            Expires January 28, 2021               [Page 26]

                     Mesh: Data At Rest Encryption             July 2020

6. DARE Container Schema

   TBS stuff

6.1. Container Headers

   TBS stuff

6.1.1. Structure: ContainerInfo

   Information that describes container information

         DataEncoding: String (Optional)

         ContainerType: String (Optional)

         Index: Integer (Optional)

         IsMeta: Boolean (Optional)

         Default: Boolean (Optional)

         TreePosition: Integer (Optional)

         IndexPosition: Integer (Optional)

         ExchangePosition: Integer (Optional)

6.2. Index Structures

   TBS stuff

6.2.1. Structure: ContainerIndex

   A container index

         Full: Boolean (Optional)

         Positions: IndexPosition [0..Many]

         Metas: IndexMeta [0..Many]

6.2.2. Structure: IndexPosition

   Specifies the position in a file at which a specified record index is
   found

         Index: Integer (Optional)

         Position: Integer (Optional)




Hallam-Baker            Expires January 28, 2021               [Page 27]

                     Mesh: Data At Rest Encryption             July 2020

6.2.3. Structure: KeyValue

   Specifies a key/value entry

         Key: String (Optional)

         Value: String (Optional)

6.2.4. Structure: IndexMeta

   Specifies the list of index entries at which a record with the
   specified metadata occurrs.

         Index: Integer [0..Many]

         ContentType: String (Optional)

         Paths: String [0..Many]

         Labels: String [0..Many]

7. Dare Container Applications

   DARE Containers are used to implement two forms of persistence store
   to support Mesh operations:

         Catalogs

         Spools

   Since DARE Containers are an append only log format, entries can only
   be modified or deleted by adding items to the log to change the
   status of previous entries. It is always possible to undo any
   operation on a catalog or spool unless the underlying container is
   purged or the individual entries modified.

7.1. Catalog

   Catalogs contain a set of entries, each of which is distinguished by
   a unique identifier.














Hallam-Baker            Expires January 28, 2021               [Page 28]

                     Mesh: Data At Rest Encryption             July 2020

   Three operations are supported:

         Add

         Update

         Delete

   The set of valid state transitions is defined by the Finite State
   machine:

   (Add-Update*-Delete)*

   Catalogs are used to represent sets of persistent objects associated
   with a Mesh Service Account. The user's set of contacts for example.
   Each contact entry may be modified many times over time but refers to
   the same subject for its entire lifetime.

   SchemaCatalog

7.2. Spool

   Spools contain lists of entries, each of which is distinguished by a
   unique identifier.

   Four operations are supported:

         Post

         Processed

         Unprocessed

         Delete

   The set of valid state transitions is defined by the Finite State
   machine:

   Post-(Processed| Unprocessed| Delete *)

   Spools are used to represent time sequence ordered entries such as
   lists of messages being sent or received, task queues and transaction
   logs.

   SchemaCatalog

7.3. Archive

   A DARE Archive is a DARE Container whose entries contain files. This
   affords the same functionality as a traditional ZIP or tar archive
   but with the added cryptographic capabilities provided by the DARE



Hallam-Baker            Expires January 28, 2021               [Page 29]

                     Mesh: Data At Rest Encryption             July 2020

   format.

8. Future Work

   The current specification describes an approach in which containers
   are written according to a strict append-only policy. Greater
   flexibility may be achieved by loosening this requirement allowing
   record(s) at the end of the container to be overwritten.

8.1. Terminal integrity check

   A major concern when operating a critical service is the possibility
   of a hardware or power failure occurring during a write operation
   causing the file update to be incomplete. While most modern operating
   systems have effective mechanisms in place to prevent corruption of
   the file system itself in such circumstances, this does not provide
   sufficient protection at the application level.

   Appending a null record containing a container-specific magic number
   provides an effective means of detecting this circumstance that can
   be quickly verified.

   If a container specifies a terminal integrity check value in the
   header of frame zero, the container is considered to be in an
   incomplete write state if the final frame is not a null record
   specifying the magic number.

   When appending new records to such containers, the old terminal
   integrity check record is overwritten by the data being added and a
   new integrity check record appended to the end.

8.2. Terminal index record

   A writer can maintain a complete (or partial) index of the container
   in its final record without additional space overhead by overwriting
   the prior index on each update.

8.3. Deferred indexing

   The task of updating terminal indexes may be deferred to a time when
   the machine is not busy. This improves responsiveness and may avoid
   the need to re-index containers receiving a sequence of updates.

   This approach may be supported by appending new entries to the end of
   the container in the usual fashion and maintaining a record of
   containers to be updated as a separate task.

   When updating the index on a container that has been updated in this
   fashion, the writer must ensure that no data is lost even if the
   process is interrupted. The use of guard records and other
   precautions against loss of state is advised.



Hallam-Baker            Expires January 28, 2021               [Page 30]

                     Mesh: Data At Rest Encryption             July 2020


9. Security Considerations

   This section describes security considerations arising from the use
   of DARE in general applications.

   Additional security considerations for use of DARE in Mesh services
   and applications are described in the Mesh Security Considerations
   guide .

9.1. Encryption/Signature nesting

9.2. Side channel

9.3. Salt reuse

10. IANA Considerations

11. Acknowledgements

   A list of people who have contributed to the design of the Mesh is
   presented in .

   The name Data At Rest Encryption was proposed by Melhi Abdulhayo?lu.

12. Appendix A: DARE Envelope Examples and Test Vectors

13. Test Examples

   In the following examples, Alice's encryption private key parameters
   are:

   {
     "PrivateKeyECDH":{
       "crv":"Ed25519",
       "Private":"_DLeB9Phh637q9vDPRast9JaKmIg9eF-lTg1UV9-sB4"}}

   Alice's signature private key parameters are:

   {
     "PrivateKeyECDH":{
       "crv":"Ed25519",
       "Private":"tWS6EyvT3r1xTk3zzv-6Ek4v5FntEq_uB4cC9gn4_MY"}}

   The body of the test message is the UTF8 representation of the
   following string:








Hallam-Baker            Expires January 28, 2021               [Page 31]

                     Mesh: Data At Rest Encryption             July 2020

   "This is a test long enough to require multiple blocks"

   The EDS sequences, are the UTF8 representation of the following
   strings:

   "Subject: Message metadata should be encrypted"
   "2018-02-01"

13.1.  Plaintext Message

   A plaintext message without associated EDS sequences is an empty
   header followed by the message body:

   {
     "DareEnvelope":[{},
       "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
     BibG9ja3M"
       ]}

13.2.  Plaintext Message with EDS

   If a plaintext message contains EDS sequences, these are also in
   plaintext:

   {
     "DareEnvelope":[{
         "Annotations":["iAEBiC1TdWJqZWN0OiBNZXNzYWdlIG1ldGFkYXRhIHNob3
     VsZCBiZSBlbmNyeXB0ZWSIAA",
           "iAECiAoyMDE4LTAyLTAxiAA"
           ]},
       "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
     BibG9ja3M"
       ]}

13.3.  Encrypted Message

   The creator generates a master session key:

   
     3C 29 54 5F  9C 24 17 3A  2C F0 BC F7  22 F2 35 9A
     2A 50 50 B3  4C 31 B1 44  5B BD D6 75  54 1D 90 45













Hallam-Baker            Expires January 28, 2021               [Page 32]

                     Mesh: Data At Rest Encryption             July 2020


   For each recipient of the message:

   The creator generates an ephemeral key:

   {
     "PrivateKeyECDH":{
       "crv":"Ed25519",
       "Private":"6QxTJ30xfSKkR7s2cJwlz0lk6rE0wsapdEmk6uVxhnM"}}

   The key agreement value is calculated:

   
     FA 99 C3 96  91 FF 86 46  CC EB CF BD  25 B8 35 6F
     B5 DE FC 02  47 2E D0 BD  CF 44 C0 1C  93 C3 E4 6B

   The key agreement value is used as the input to a HKDF key derivation
   function with the info parameter  master to create the key used to
   wrap the master key:

   
     5D 5D F6 85  FF FB 2C 5D  CD 79 F8 CD  A1 9B 80 57
     CA 27 65 04  9F 33 AB D5  92 AB 77 31  6D E7 A0 16

   The wrapped master key is:

   
     CF 0E A3 92  4C 02 4C 41  EE A8 4F 9E  F5 84 BC 11
     5B 53 5E 98  14 BC D0 44  18 41 58 B0  14 3B D8 CF
     5E 4B 6D AB  89 1F 06 86

   This information is used to calculate the Recipient information shown
   in the example below.

   To encrypt a message, we first generate a unique salt value:

   
     58 23 17 AB  4A 4E 6C CC  8A 32 8D 62  C6 D9 52 7C

   The salt value and master key are used to generate the payload
   encryption key:

   
     A3 57 FF DC  00 A9 2E 1A  80 8E 15 58  05 5E 40 1C
     CF B8 1A 0C  A8 90 45 9E  97 4E 94 27  7F A0 34 64

   Since AES is a block cipher, we also require an initializarion
   vector:






Hallam-Baker            Expires January 28, 2021               [Page 33]

                     Mesh: Data At Rest Encryption             July 2020

   
     6B 70 DC 64  5F 41 51 C7  89 67 70 BF  E3 03 A2 DA

   The output sequence is the encrypted bytes:

   
     57 CB 1F 8B  E9 0F 00 7F  E2 26 35 6B  B6 06 59 A3
     2E 2D F3 DB  76 91 1B 20  D3 CD 02 66  65 80 0A D2
     21 7A 9F 7C  D3 D8 20 22  FA D4 11 86  23 B6 81 0D
     FE 21 9F A7  1B 82 B8 3C  AB 58 6C F7  AC E2 02 A0

   Since the message is not signed, there is no need for a trailer. The
   completed message is:

   {
     "DareEnvelope":[{
         "enc":"A256CBC",
         "kid":"EBQO-WNI4-BRD4-TY3E-UDGO-5X75-6675",
         "Salt":"WCMXq0pObMyKMo1ixtlSfA",
         "recipients":[{
             "kid":"MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
             "epk":{
               "PublicKeyECDH":{
                 "crv":"Ed25519",
                 "Public":"BsEDw9N8SWsy8RnTUobi9LxdoF5ctlv2pmRF6QQ2ijA"}},
             "wmk":"zw6jkkwCTEHuqE-e9YS8EVtTXpgUvNBEGEFYsBQ72M9eS22riR
     8Ghg"}
           ]},
       "V8sfi-kPAH_iJjVrtgZZoy4t89t2kRsg080CZmWACtIhep9809ggIvrUEYYjto
     EN_iGfpxuCuDyrWGz3rOICoA"
       ]}

13.4.  Signed Message

   Signed messages specify the digest algorithm to be used in the header
   and the signature value in the trailer. Note that the digest
   algorithm is not optional since it serves as notice that a decoder
   should digest the payload value  to enable signature verification.

   {
     "DareEnvelope":[{
         "dig":"SHA2"},
       "VGhpcyBpcyBhIHRlc3QgbG9uZyBlbm91Z2ggdG8gcmVxdWlyZSBtdWx0aXBsZS
     BibG9ja3M",
       {
         "signatures":[{
             "alg":"SHA2",
             "kid":"MCZH-3KUN-DZH5-GSPY-6KV5-A43N-DFF3",
             "signature":"_hLBDZT8oZozrwweypbtmSl_rtqmuZNjnF4343VZxEqz
     94A72B-_qluqYqXzNO0PyoO6xUyrHZ3QjhzBa4TjAg"}
           ],



Hallam-Baker            Expires January 28, 2021               [Page 34]

                     Mesh: Data At Rest Encryption             July 2020

         "PayloadDigest":"raim8SV5adPbWWn8FMM4mrRAQCO9A2jZ0NZAnFXWlG0x
     F6sWGJbnKSdtIJMmMU_hjarlIPEoY3vy9UdVlH5KAg"}
       ]}

13.5.  Signed and Encrypted Message

   A signed and encrypted message is encrypted and then signed. The
   signer proves knowledge of the payload plaintext by providing the
   plaintext witness value.

   {
     "DareEnvelope":[{
         "enc":"A256CBC",
         "dig":"SHA2",
         "kid":"EBQJ-ABSI-QR3P-XSEY-RJQT-45MV-FDN2",
         "Salt":"cfY_McNrYQDbxeIG3bS2TA",
         "recipients":[{
             "kid":"MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
             "epk":{
               "PublicKeyECDH":{
                 "crv":"Ed25519",
                 "Public":"7uJciy6zYF43EXDcqPz6btXMdpopnPeE1gZYzZINKS0"}},
             "wmk":"wkgWkMQ9EllWy-ji8erztJCgUuKGm2vDueSdM_cR6IGndwvHod
     Y6JQ"}
           ]},
       "iE2cIZWiR8U1mH7j8cyK-PcdSyZM0LdkE_nbMXm9cOJqQwSI78gNs1qzZd0L1T
     Aah3XG5uDTDjw-e2XbVGOy2Q",
       {
         "signatures":[{
             "alg":"SHA2",
             "kid":"MCZH-3KUN-DZH5-GSPY-6KV5-A43N-DFF3",
             "signature":"iUjTTlN5ofNjyoMfmeXY4L6y8QCvyE8y1zHoJRuVD3po
     -dP2BL_VOfc-qDLg6PM8O4b8NKMHfCmRba1WfnWkCw",
             "witness":"kl3qVDZaaDWYnOjhDwvE7JHs-Q_tG1xJrYfq0vc4Ag8"}
           ],
         "PayloadDigest":"ohlZ-KKC10cqZ7rQwmEhANTDRDV2vsPQu2DKnfXFChgN
     f5jLfiNdIwi4IkBLcllGGANITDKyyg6fmPSMCnTrqw"}
       ]}

14. Appendix B: DARE Container Examples and Test Vectors

   The data payloads in all the following examples are identical, only
   the authentication and/or encryption is different.

         *   Frame 1..n consists of 300 bytes being the byte sequence
            00, 01, 02, etc.  repeating after 256 bytes.

   For conciseness, the raw data format is omitted for examples after
   the first, except where the data payload has been transformed, (i.e.
   encrypted).




Hallam-Baker            Expires January 28, 2021               [Page 35]

                     Mesh: Data At Rest Encryption             July 2020

14.1. Simple container

   the following example shows a simple container with first frame and a
   single data frame:

   f4 82 
   f0 7c 
   f0 00 
   f0 00 
   82 f4 
   f5 01 74 
   f0 43 
   f1 01 2c 
   74 01 f5 

   Since there is no integrity check, there is no need for trailer
   entries. The header values are:

   Frame 0

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "List",
       "Index": 0}}
   
   [Empty trailer]

   Frame 1

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1}}
   
   [Empty trailer]

14.2. Payload and chain digests

   The following example shows a chain container with a first frame and
   three  data frames. The headers of these frames is the same as before
   but the frames now have trailers specifying the PayloadDigest and
   ChainDigest values:










Hallam-Baker            Expires January 28, 2021               [Page 36]

                     Mesh: Data At Rest Encryption             July 2020

   Frame 0

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "Chain",
       "Index": 0}}
   
   [Empty trailer]

   Frame 1

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
     Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}

   Frame 2

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 2}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
     Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}

   Frame 3

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 3}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "ChainDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVR
     Vz9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}





Hallam-Baker            Expires January 28, 2021               [Page 37]

                     Mesh: Data At Rest Encryption             July 2020

14.3. Merkle Tree

   The following example shows a chain container with a first frame and
   six  data frames. The trailers now contain the TreePosition and
   TreeDigest values:

   Frame 0

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "Merkle",
       "Index": 0}}
   
   [Empty trailer]

   Frame 1

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1,
       "TreePosition": 0}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
     z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}

   Frame 2

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 2,
       "TreePosition": 360}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "7fHmkEIsPkN6sDYAOLvpIJn5Dg3PxDDAaq-ll2kh8722kokk
     FnZQcYtjuVC71aHNXI18q-lPnfRkmwryG-bhqQ"}










Hallam-Baker            Expires January 28, 2021               [Page 38]

                     Mesh: Data At Rest Encryption             July 2020


   Frame 3

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 3,
       "TreePosition": 360}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
     z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}

   Frame 4

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 4,
       "TreePosition": 1612}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "vJ6ngNATvZcXSMALi5IUqzl1GBxBnTNVcC87VL_BhMRCbAvK
     Sj8gs0VFgxxLkZ2myrtaDIwhHoswiTiBMLNWug"}

   Frame 5

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 5,
       "TreePosition": 1612}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
     z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}












Hallam-Baker            Expires January 28, 2021               [Page 39]

                     Mesh: Data At Rest Encryption             July 2020


   Frame 6

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 6,
       "TreePosition": 2867}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "WgHlz3EHczVPqgtpc39Arv7CFIsCbFVsk8wg0j2qLlEfur9S
     Z0mdr65Ka-HF0Qx8gg_DAoiJwUrwADDXyxVJOg"}

14.4. Signed container

   The following example shows a tree container with a signature in the
   final record. The signing key parameters are:

   {
     "PrivateKeyECDH":{
       "crv":"Ed25519",
       "Private":"tWS6EyvT3r1xTk3zzv-6Ek4v5FntEq_uB4cC9gn4_MY"}}

   The container headers and trailers are:

   Frame 0

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "Merkle",
       "Index": 0}}
   
   [Empty trailer]

   Frame 1

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1,
       "TreePosition": 0}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "T7S1FcrgY3AaWD4L-t5W1K-3XYkPTcOdGEGyjglTD6yMYVRV
     z9tn_KQc6GdA-P4VSRigBygV65OEd2Vv3YDhww"}



Hallam-Baker            Expires January 28, 2021               [Page 40]

                     Mesh: Data At Rest Encryption             July 2020


   Frame 2

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 2,
       "TreePosition": 360}}
   
   {
     "PayloadDigest": "8dyi62d7MDJlsLm6_w4GEgKBjzXBRwppu6qbtmAl6UjZD
     lZeaWQlBsYhOu88-ekpNXpZ2iY96zTRI229zaJ5sw",
     "TreeDigest": "7fHmkEIsPkN6sDYAOLvpIJn5Dg3PxDDAaq-ll2kh8722kokk
     FnZQcYtjuVC71aHNXI18q-lPnfRkmwryG-bhqQ"}

14.5. Encrypted container

   The following example shows a container in which all the frame
   payloads are encrypted  under the same master secret established in a
   key agreement specified in the first frame.

   Frame 0

   {
     "enc": "A256CBC",
     "kid": "EBQL-FP4Q-VW6U-OIXJ-T2XF-KVR2-IBEY",
     "Salt": "mZK5G7GpPyUduKKAz4FcbA",
     "recipients": [{
         "kid": "MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
         "epk": {
           "PublicKeyECDH": {
             "crv": "Ed25519",
             "Public": "uxpnx3YY5dSJ4_OnEQbyuTDqvXGctJIVCIaNr4drKUk"}},
         "wmk": "Dywrqtijd4UBfMoUb3ispnnE0jOKc-R2wpj2oVRCYq8kJl2awrKQGw"}],
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "List",
       "Index": 0}}
   
   [Empty trailer]













Hallam-Baker            Expires January 28, 2021               [Page 41]

                     Mesh: Data At Rest Encryption             July 2020


   Frame 1

   {
     "enc": "A256CBC",
     "kid": "EBQL-FP4Q-VW6U-OIXJ-T2XF-KVR2-IBEY",
     "Salt": "pfVBV9TTZNwDdLX_xrElXw",
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1}}
   
   [Empty trailer]

   Frame 2

   {
     "enc": "A256CBC",
     "kid": "EBQL-FP4Q-VW6U-OIXJ-T2XF-KVR2-IBEY",
     "Salt": "GCBNz5X8M8QFKDANMYz77g",
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 2}}
   
   [Empty trailer]

   Here are the container bytes. Note that the content is now encrypted
   and has expanded by 25 bytes. These are the salt (16 bytes), the AES
   padding (4 bytes) and the  JSON-B framing (5 bytes).

   f5 02 14 
   f1 01 fd 
   f0 10 
   f0 00 
   14 02 f5 
   f5 01 df 
   f0 aa 
   f1 01 30 
   df 01 f5 
   f5 01 df 
   f0 aa 
   f1 01 30 
   df 01 f5 
   

   The following example shows a container in which all the frame
   payloads are encrypted  under separate key agreements specified in
   the payload frames.







Hallam-Baker            Expires January 28, 2021               [Page 42]

                     Mesh: Data At Rest Encryption             July 2020

   Frame 0

   {
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "DataEncoding": "JSON",
       "ContainerType": "List",
       "Index": 0}}
   
   [Empty trailer]

   Frame 1

   {
     "enc": "A256CBC",
     "kid": "EBQM-SELQ-Y22B-CDPW-FNCJ-FLB6-SGGH",
     "Salt": "j14twaGXh43vUKNLMJVxgQ",
     "recipients": [{
         "kid": "MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
         "epk": {
           "PublicKeyECDH": {
             "crv": "Ed25519",
             "Public": "eHz0G-dzVzdP1HPxdOgthCWVlJOJBmpMloaPZ6aq4BI"}},
         "wmk": "2_WjXkSyyLNV0Y8vjE_Im32avwKoa4AT8qHGYsgYhMEY6nxTyz5kmQ"}],
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 1}}
   
   [Empty trailer]

   Frame 2

   {
     "enc": "A256CBC",
     "kid": "EBQM-HQ6B-RN74-WCLJ-ZZRC-TKTJ-6D7H",
     "Salt": "0syPXTpbZ9VICdazMCwyJg",
     "recipients": [{
         "kid": "MAZQ-4ASQ-M4GB-2AH6-JYBJ-G7ME-3GP3",
         "epk": {
           "PublicKeyECDH": {
             "crv": "Ed25519",
             "Public": "OFPZyvMl2_uUJRjsYUmflnhReptUo3N0NnYviBAlZsg"}},
         "wmk": "0zm3VI4ReK6uRaAnQlxxHRb2O16J_A2paV9SNwHEhq2ZNUQiLq8z9Q"}],
     "ContentMetaData": "e30",
     "ContainerInfo": {
       "Index": 2}}
   
   [Empty trailer]






Hallam-Baker            Expires January 28, 2021               [Page 43]

                     Mesh: Data At Rest Encryption             July 2020

15. Appendix C: Previous Frame Function

   public long PreviousFrame (long Frame) {
       long x2 = Frame + 1; 
       long d = 1; 
   
       while (x2 > 0) {
           if ((x2 & 1) == 1) {
               return x2 == 1 ? (d / 2) - 1 : Frame - d; 
               }
           d = d * 2; 
           x2 = x2 / 2; 
           }
       return 0; 
       }

16. Appendix D: Outstanding Issues

   The following issues need to be addressed.

   +-------------------------+-----------------------------------------+
   | Issue                   | Description                             |
   +-------------------------+-----------------------------------------+
   | X25519                  | The examples currently use Edwards      |
   |                         | Curve25519 for encryption. This should  |
   |                         | be Curve X25519                         |
   | Indexing                | No examples are given of indexing a     |
   |                         | container                               |
   | Archive                 | Should include a file archive example   |
   | File Path               | Mention the file path security issue in |
   |                         | the security considerations             |
   | Security Considerations | Write Security considerations           |
   | AES-GCM                 | Switch to using AES GCM in the examples |
   | Witness                 | Complete handling of witness values.    |
   | Schema                  | Complete the schema documentation       |
   | Container Redo          | Rework the container/header objects so  |
   |                         | that these are separate classes and     |
   |                         | Header is an entry in the Container     |
   |                         | header.                                 |

References

Normative References

   [RFC7515]  Jones, M.,Bradley, J.,Sakimura, N., "JSON Web Signature
              (JWS)", RFC 7515, DOI 10.17487/RFC7515, May 2015.

   [draft-hallambaker-mesh-security]  Hallam-Baker, P, "Mathematical
              Mesh 3.0 Part VII: Security Considerations", Internet-
              Draft draft-hallambaker-mesh-security-04, 9 March 2020.




Hallam-Baker            Expires January 28, 2021               [Page 44]

                     Mesh: Data At Rest Encryption             July 2020

   [draft-hallambaker-mesh-udf]  Hallam-Baker, P, "Mathematical Mesh 3.0
              Part II: Uniform Data Fingerprint.", Internet-Draft draft-
              hallambaker-mesh-udf-09, 9 March 2020.

   [draft-hallambaker-jsonbcd]  Hallam-Baker, P, "Binary Encodings for
              JavaScript Object Notation: JSON-B, JSON-C, JSON-D",
              Internet-Draft draft-hallambaker-jsonbcd-15, 23 October
              2019.

   [RFC6838]  Freed, N.,Klensin, J.,Hansen, T., "Media Type
              Specifications and Registration Procedures", BCP 13, RFC
              6838, DOI 10.17487/RFC6838, January 2013.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2", FYI
              36, RFC 4949, DOI 10.17487/RFC4949, August 2007.

   [RFC7518]  Jones, M., "JSON Web Algorithms (JWA)", RFC 7518, DOI
              10.17487/RFC7518, May 2015.

   [draft-hallambaker-mesh-architecture]  Hallam-Baker, P, "Mathematical
              Mesh 3.0 Part I: Architecture Guide", Internet-Draft
              draft-hallambaker-mesh-architecture-13, 9 March 2020.

   [RFC3394]  Schaad, J.,Housley, R., "Advanced Encryption Standard
              (AES) Key Wrap Algorithm", RFC 3394, DOI 10.17487/RFC3394,
              September 2002.

   [RFC2315]  Kaliski, B., "PKCS #7: Cryptographic Message Syntax
              Version 1.5", RFC 2315, DOI 10.17487/RFC2315, March 1998.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, DOI
              10.17487/RFC2119, March 1997.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, DOI 10.17487/RFC7159, March
              2014.

   [RFC5869]  Krawczyk, H.,Eronen, P., "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869, DOI
              10.17487/RFC5869, May 2010.

   [RFC4880]  Callas, J.,Donnerhacke, L.,Finney, H.,Shaw, D.,Thayer, R.,
              "OpenPGP Message Format", RFC 4880, DOI 10.17487/RFC4880,
              November 2007.

   [RFC7516]  Jones, M.,Hildebrand, J., "JSON Web Encryption (JWE)", RFC
              7516, DOI 10.17487/RFC7516, May 2015.






Hallam-Baker            Expires January 28, 2021               [Page 45]

                     Mesh: Data At Rest Encryption             July 2020

   [RFC7517]  Jones, M., "JSON Web Key (JWK)", RFC 7517, DOI
              10.17487/RFC7517, May 2015.

   [IANAJOSE]  , "[Reference Not Found!]".

Informative References

   [Davis2001]  ,Davis, D., "Defective Sign & Encrypt in S/MIME, PKCS#7,
              MOSS, PEM, PGP, and XML", May 2001.

   [ZIPFILE]  , "APPNOTE.TXT - .ZIP File Format Specification ", October
              2014.

   [BLOCKCHAIN]  , "Blockchain Specification ".

   [RFC5652]  ,Housley, R., "Cryptographic Message Syntax (CMS)", STD
              70, RFC 5652, DOI 10.17487/RFC5652, September 2009.

Author's Address

   Phillip Hallam-Baker
   ThresholdSecrets.com

   phill@hallambaker.com






























Hallam-Baker            Expires January 28, 2021               [Page 46]
